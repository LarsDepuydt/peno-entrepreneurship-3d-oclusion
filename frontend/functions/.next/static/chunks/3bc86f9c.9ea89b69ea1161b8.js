"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[884],{3687:function(t,e,i){let s,n,o,r,l,a,h;i.d(e,{AO:function(){return d},JO:function(){return t6},KK:function(){return ti},_f:function(){return b},np:function(){return et},q3:function(){return iP},uT:function(){return j},wf:function(){return ev}});class u{constructor(t){void 0===t&&(t=[0,0,0,0,0,0,0,0,0]),this.elements=t}identity(){let t=this.elements;t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1}setZero(){let t=this.elements;t[0]=0,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t[8]=0}setTrace(t){let e=this.elements;e[0]=t.x,e[4]=t.y,e[8]=t.z}getTrace(t){void 0===t&&(t=new d);let e=this.elements;return t.x=e[0],t.y=e[4],t.z=e[8],t}vmult(t,e){void 0===e&&(e=new d);let i=this.elements,s=t.x,n=t.y,o=t.z;return e.x=i[0]*s+i[1]*n+i[2]*o,e.y=i[3]*s+i[4]*n+i[5]*o,e.z=i[6]*s+i[7]*n+i[8]*o,e}smult(t){for(let e=0;e<this.elements.length;e++)this.elements[e]*=t}mmult(t,e){void 0===e&&(e=new u);let i=this.elements,s=t.elements,n=e.elements,o=i[0],r=i[1],l=i[2],a=i[3],h=i[4],c=i[5],d=i[6],p=i[7],y=i[8],v=s[0],w=s[1],m=s[2],f=s[3],g=s[4],x=s[5],b=s[6],E=s[7],z=s[8];return n[0]=o*v+r*f+l*b,n[1]=o*w+r*g+l*E,n[2]=o*m+r*x+l*z,n[3]=a*v+h*f+c*b,n[4]=a*w+h*g+c*E,n[5]=a*m+h*x+c*z,n[6]=d*v+p*f+y*b,n[7]=d*w+p*g+y*E,n[8]=d*m+p*x+y*z,e}scale(t,e){void 0===e&&(e=new u);let i=this.elements,s=e.elements;for(let e=0;3!==e;e++)s[3*e+0]=t.x*i[3*e+0],s[3*e+1]=t.y*i[3*e+1],s[3*e+2]=t.z*i[3*e+2];return e}solve(t,e){let i,s,n,o;void 0===e&&(e=new d);let r=[];for(i=0;i<12;i++)r.push(0);for(i=0;i<3;i++)for(s=0;s<3;s++)r[i+4*s]=this.elements[i+3*s];r[3]=t.x,r[7]=t.y,r[11]=t.z;let l=3,a=l;do{if(0===r[(i=a-l)+4*i]){for(s=i+1;s<a;s++)if(0!==r[i+4*s]){n=4;do o=4-n,r[o+4*i]+=r[o+4*s];while(--n);break}}if(0!==r[i+4*i])for(s=i+1;s<a;s++){let t=r[i+4*s]/r[i+4*i];n=4;do r[(o=4-n)+4*s]=o<=i?0:r[o+4*s]-r[o+4*i]*t;while(--n)}}while(--l);if(e.z=r[11]/r[10],e.y=(r[7]-r[6]*e.z)/r[5],e.x=(r[3]-r[2]*e.z-r[1]*e.y)/r[0],isNaN(e.x)||isNaN(e.y)||isNaN(e.z)||e.x===1/0||e.y===1/0||e.z===1/0)throw`Could not solve equation! Got x=[${e.toString()}], b=[${t.toString()}], A=[${this.toString()}]`;return e}e(t,e,i){if(void 0===i)return this.elements[e+3*t];this.elements[e+3*t]=i}copy(t){for(let e=0;e<t.elements.length;e++)this.elements[e]=t.elements[e];return this}toString(){let t="";for(let e=0;e<9;e++)t+=this.elements[e]+",";return t}reverse(t){let e,i,s,n;void 0===t&&(t=new u);let o=c;for(e=0;e<3;e++)for(i=0;i<3;i++)o[e+6*i]=this.elements[e+3*i];o[3]=1,o[9]=0,o[15]=0,o[4]=0,o[10]=1,o[16]=0,o[5]=0,o[11]=0,o[17]=1;let r=3,l=r;do{if(0===o[(e=l-r)+6*e]){for(i=e+1;i<l;i++)if(0!==o[e+6*i]){s=6;do n=6-s,o[n+6*e]+=o[n+6*i];while(--s);break}}if(0!==o[e+6*e])for(i=e+1;i<l;i++){let t=o[e+6*i]/o[e+6*e];s=6;do o[(n=6-s)+6*i]=n<=e?0:o[n+6*i]-o[n+6*e]*t;while(--s)}}while(--r);e=2;do{i=e-1;do{let t=o[e+6*i]/o[e+6*e];s=6;do o[(n=6-s)+6*i]=o[n+6*i]-o[n+6*e]*t;while(--s)}while(i--)}while(--e);e=2;do{let t=1/o[e+6*e];s=6;do o[(n=6-s)+6*e]=o[n+6*e]*t;while(--s)}while(e--);e=2;do{i=2;do{if(isNaN(n=o[3+i+6*e])||n===1/0)throw`Could not reverse! A=[${this.toString()}]`;t.e(e,i,n)}while(i--)}while(e--);return t}setRotationFromQuaternion(t){let e=t.x,i=t.y,s=t.z,n=t.w,o=e+e,r=i+i,l=s+s,a=e*o,h=e*r,u=e*l,c=i*r,d=i*l,p=s*l,y=n*o,v=n*r,w=n*l,m=this.elements;return m[0]=1-(c+p),m[1]=h-w,m[2]=u+v,m[3]=h+w,m[4]=1-(a+p),m[5]=d-y,m[6]=u-v,m[7]=d+y,m[8]=1-(a+c),this}transpose(t){let e;void 0===t&&(t=new u);let i=this.elements,s=t.elements;return s[0]=i[0],s[4]=i[4],s[8]=i[8],e=i[1],s[1]=i[3],s[3]=e,e=i[2],s[2]=i[6],s[6]=e,e=i[5],s[5]=i[7],s[7]=e,t}}let c=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class d{constructor(t,e,i){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),this.x=t,this.y=e,this.z=i}cross(t,e){void 0===e&&(e=new d);let i=t.x,s=t.y,n=t.z,o=this.x,r=this.y,l=this.z;return e.x=r*n-l*s,e.y=l*i-o*n,e.z=o*s-r*i,e}set(t,e,i){return this.x=t,this.y=e,this.z=i,this}setZero(){this.x=this.y=this.z=0}vadd(t,e){if(!e)return new d(this.x+t.x,this.y+t.y,this.z+t.z);e.x=t.x+this.x,e.y=t.y+this.y,e.z=t.z+this.z}vsub(t,e){if(!e)return new d(this.x-t.x,this.y-t.y,this.z-t.z);e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z}crossmat(){return new u([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){let t=this.x,e=this.y,i=this.z,s=Math.sqrt(t*t+e*e+i*i);if(s>0){let t=1/s;this.x*=t,this.y*=t,this.z*=t}else this.x=0,this.y=0,this.z=0;return s}unit(t){void 0===t&&(t=new d);let e=this.x,i=this.y,s=this.z,n=Math.sqrt(e*e+i*i+s*s);return n>0?(n=1/n,t.x=e*n,t.y=i*n,t.z=s*n):(t.x=1,t.y=0,t.z=0),t}length(){let t=this.x,e=this.y,i=this.z;return Math.sqrt(t*t+e*e+i*i)}lengthSquared(){return this.dot(this)}distanceTo(t){let e=this.x,i=this.y,s=this.z,n=t.x,o=t.y,r=t.z;return Math.sqrt((n-e)*(n-e)+(o-i)*(o-i)+(r-s)*(r-s))}distanceSquared(t){let e=this.x,i=this.y,s=this.z,n=t.x,o=t.y,r=t.z;return(n-e)*(n-e)+(o-i)*(o-i)+(r-s)*(r-s)}scale(t,e){void 0===e&&(e=new d);let i=this.x,s=this.y,n=this.z;return e.x=t*i,e.y=t*s,e.z=t*n,e}vmul(t,e){return void 0===e&&(e=new d),e.x=t.x*this.x,e.y=t.y*this.y,e.z=t.z*this.z,e}addScaledVector(t,e,i){return void 0===i&&(i=new d),i.x=this.x+t*e.x,i.y=this.y+t*e.y,i.z=this.z+t*e.z,i}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(t){return void 0===t&&(t=new d),t.x=-this.x,t.y=-this.y,t.z=-this.z,t}tangents(t,e){let i=this.length();if(i>0){let s=1/i;p.set(this.x*s,this.y*s,this.z*s),.9>Math.abs(p.x)?(y.set(1,0,0),p.cross(y,t)):(y.set(0,1,0),p.cross(y,t)),p.cross(t,e)}else t.set(1,0,0),e.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}lerp(t,e,i){let s=this.x,n=this.y,o=this.z;i.x=s+(t.x-s)*e,i.y=n+(t.y-n)*e,i.z=o+(t.z-o)*e}almostEquals(t,e){return void 0===e&&(e=1e-6),!(Math.abs(this.x-t.x)>e||Math.abs(this.y-t.y)>e||Math.abs(this.z-t.z)>e)}almostZero(t){return void 0===t&&(t=1e-6),!(Math.abs(this.x)>t||Math.abs(this.y)>t||Math.abs(this.z)>t)}isAntiparallelTo(t,e){return this.negate(v),v.almostEquals(t,e)}clone(){return new d(this.x,this.y,this.z)}}d.ZERO=new d(0,0,0),d.UNIT_X=new d(1,0,0),d.UNIT_Y=new d(0,1,0),d.UNIT_Z=new d(0,0,1);let p=new d,y=new d,v=new d;class w{constructor(t){void 0===t&&(t={}),this.lowerBound=new d,this.upperBound=new d,t.lowerBound&&this.lowerBound.copy(t.lowerBound),t.upperBound&&this.upperBound.copy(t.upperBound)}setFromPoints(t,e,i,s){let n=this.lowerBound,o=this.upperBound;n.copy(t[0]),i&&i.vmult(n,n),o.copy(n);for(let e=1;e<t.length;e++){let s=t[e];i&&(i.vmult(s,m),s=m),s.x>o.x&&(o.x=s.x),s.x<n.x&&(n.x=s.x),s.y>o.y&&(o.y=s.y),s.y<n.y&&(n.y=s.y),s.z>o.z&&(o.z=s.z),s.z<n.z&&(n.z=s.z)}return e&&(e.vadd(n,n),e.vadd(o,o)),s&&(n.x-=s,n.y-=s,n.z-=s,o.x+=s,o.y+=s,o.z+=s),this}copy(t){return this.lowerBound.copy(t.lowerBound),this.upperBound.copy(t.upperBound),this}clone(){return new w().copy(this)}extend(t){this.lowerBound.x=Math.min(this.lowerBound.x,t.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,t.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,t.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,t.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,t.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,t.upperBound.z)}overlaps(t){let e=this.lowerBound,i=this.upperBound,s=t.lowerBound,n=t.upperBound,o=s.x<=i.x&&i.x<=n.x||e.x<=n.x&&n.x<=i.x,r=s.y<=i.y&&i.y<=n.y||e.y<=n.y&&n.y<=i.y,l=s.z<=i.z&&i.z<=n.z||e.z<=n.z&&n.z<=i.z;return o&&r&&l}volume(){let t=this.lowerBound,e=this.upperBound;return(e.x-t.x)*(e.y-t.y)*(e.z-t.z)}contains(t){let e=this.lowerBound,i=this.upperBound,s=t.lowerBound,n=t.upperBound;return e.x<=s.x&&i.x>=n.x&&e.y<=s.y&&i.y>=n.y&&e.z<=s.z&&i.z>=n.z}getCorners(t,e,i,s,n,o,r,l){let a=this.lowerBound,h=this.upperBound;t.copy(a),e.set(h.x,a.y,a.z),i.set(h.x,h.y,a.z),s.set(a.x,h.y,h.z),n.set(h.x,a.y,h.z),o.set(a.x,h.y,a.z),r.set(a.x,a.y,h.z),l.copy(h)}toLocalFrame(t,e){let i=f[0],s=f[1],n=f[2],o=f[3],r=f[4],l=f[5],a=f[6],h=f[7];this.getCorners(i,s,n,o,r,l,a,h);for(let e=0;8!==e;e++){let i=f[e];t.pointToLocal(i,i)}return e.setFromPoints(f)}toWorldFrame(t,e){let i=f[0],s=f[1],n=f[2],o=f[3],r=f[4],l=f[5],a=f[6],h=f[7];this.getCorners(i,s,n,o,r,l,a,h);for(let e=0;8!==e;e++){let i=f[e];t.pointToWorld(i,i)}return e.setFromPoints(f)}overlapsRay(t){let{direction:e,from:i}=t,s=1/e.x,n=1/e.y,o=1/e.z,r=(this.lowerBound.x-i.x)*s,l=(this.upperBound.x-i.x)*s,a=(this.lowerBound.y-i.y)*n,h=(this.upperBound.y-i.y)*n,u=(this.lowerBound.z-i.z)*o,c=(this.upperBound.z-i.z)*o,d=Math.min(Math.min(Math.max(r,l),Math.max(a,h)),Math.max(u,c));return!(d<0||Math.max(Math.max(Math.min(r,l),Math.min(a,h)),Math.min(u,c))>d)}}let m=new d,f=[new d,new d,new d,new d,new d,new d,new d,new d];class g{constructor(){this.matrix=[]}get(t,e){let{index:i}=t,{index:s}=e;if(s>i){let t=s;s=i,i=t}return this.matrix[(i*(i+1)>>1)+s-1]}set(t,e,i){let{index:s}=t,{index:n}=e;if(n>s){let t=n;n=s,s=t}this.matrix[(s*(s+1)>>1)+n-1]=i?1:0}reset(){for(let t=0,e=this.matrix.length;t!==e;t++)this.matrix[t]=0}setNumObjects(t){this.matrix.length=t*(t-1)>>1}}class x{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});let i=this._listeners;return void 0===i[t]&&(i[t]=[]),i[t].includes(e)||i[t].push(e),this}hasEventListener(t,e){if(void 0===this._listeners)return!1;let i=this._listeners;return!!(void 0!==i[t]&&i[t].includes(e))}hasAnyEventListener(t){if(void 0===this._listeners)return!1;let e=this._listeners;return void 0!==e[t]}removeEventListener(t,e){if(void 0===this._listeners)return this;let i=this._listeners;if(void 0===i[t])return this;let s=i[t].indexOf(e);return -1!==s&&i[t].splice(s,1),this}dispatchEvent(t){if(void 0===this._listeners)return this;let e=this._listeners,i=e[t.type];if(void 0!==i){t.target=this;for(let e=0,s=i.length;e<s;e++)i[e].call(this,t)}return this}}class b{constructor(t,e,i,s){void 0===t&&(t=0),void 0===e&&(e=0),void 0===i&&(i=0),void 0===s&&(s=1),this.x=t,this.y=e,this.z=i,this.w=s}set(t,e,i,s){return this.x=t,this.y=e,this.z=i,this.w=s,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(t,e){let i=Math.sin(.5*e);return this.x=t.x*i,this.y=t.y*i,this.z=t.z*i,this.w=Math.cos(.5*e),this}toAxisAngle(t){void 0===t&&(t=new d),this.normalize();let e=2*Math.acos(this.w),i=Math.sqrt(1-this.w*this.w);return i<.001?(t.x=this.x,t.y=this.y,t.z=this.z):(t.x=this.x/i,t.y=this.y/i,t.z=this.z/i),[t,e]}setFromVectors(t,e){if(t.isAntiparallelTo(e))t.tangents(E,z),this.setFromAxisAngle(E,Math.PI);else{let i=t.cross(e);this.x=i.x,this.y=i.y,this.z=i.z,this.w=Math.sqrt(t.length()**2*e.length()**2)+t.dot(e),this.normalize()}return this}mult(t,e){void 0===e&&(e=new b);let i=this.x,s=this.y,n=this.z,o=this.w,r=t.x,l=t.y,a=t.z,h=t.w;return e.x=i*h+o*r+s*a-n*l,e.y=s*h+o*l+n*r-i*a,e.z=n*h+o*a+i*l-s*r,e.w=o*h-i*r-s*l-n*a,e}inverse(t){void 0===t&&(t=new b);let e=this.x,i=this.y,s=this.z,n=this.w;this.conjugate(t);let o=1/(e*e+i*i+s*s+n*n);return t.x*=o,t.y*=o,t.z*=o,t.w*=o,t}conjugate(t){return void 0===t&&(t=new b),t.x=-this.x,t.y=-this.y,t.z=-this.z,t.w=this.w,t}normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===t?(this.x=0,this.y=0,this.z=0,this.w=0):(t=1/t,this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}normalizeFast(){let t=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===t?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}vmult(t,e){void 0===e&&(e=new d);let i=t.x,s=t.y,n=t.z,o=this.x,r=this.y,l=this.z,a=this.w,h=a*i+r*n-l*s,u=a*s+l*i-o*n,c=a*n+o*s-r*i,p=-o*i-r*s-l*n;return e.x=h*a+-(p*o)+-(u*l)- -(c*r),e.y=u*a+-(p*r)+-(c*o)- -(h*l),e.z=c*a+-(p*l)+-(h*r)- -(u*o),e}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}toEuler(t,e){let i,s,n;void 0===e&&(e="YZX");let o=this.x,r=this.y,l=this.z,a=this.w;if("YZX"===e){let t=o*r+l*a;if(t>.499&&(i=2*Math.atan2(o,a),s=Math.PI/2,n=0),t<-.499&&(i=-2*Math.atan2(o,a),s=-Math.PI/2,n=0),void 0===i){let e=l*l;i=Math.atan2(2*r*a-2*o*l,1-2*(r*r)-2*e),s=Math.asin(2*t),n=Math.atan2(2*o*a-2*r*l,1-2*(o*o)-2*e)}}else throw Error(`Euler order ${e} not supported yet.`);t.y=i,t.z=s,t.x=n}setFromEuler(t,e,i,s){void 0===s&&(s="XYZ");let n=Math.cos(t/2),o=Math.cos(e/2),r=Math.cos(i/2),l=Math.sin(t/2),a=Math.sin(e/2),h=Math.sin(i/2);return"XYZ"===s?(this.x=l*o*r+n*a*h,this.y=n*a*r-l*o*h,this.z=n*o*h+l*a*r,this.w=n*o*r-l*a*h):"YXZ"===s?(this.x=l*o*r+n*a*h,this.y=n*a*r-l*o*h,this.z=n*o*h-l*a*r,this.w=n*o*r+l*a*h):"ZXY"===s?(this.x=l*o*r-n*a*h,this.y=n*a*r+l*o*h,this.z=n*o*h+l*a*r,this.w=n*o*r-l*a*h):"ZYX"===s?(this.x=l*o*r-n*a*h,this.y=n*a*r+l*o*h,this.z=n*o*h-l*a*r,this.w=n*o*r+l*a*h):"YZX"===s?(this.x=l*o*r+n*a*h,this.y=n*a*r+l*o*h,this.z=n*o*h-l*a*r,this.w=n*o*r-l*a*h):"XZY"===s&&(this.x=l*o*r-n*a*h,this.y=n*a*r-l*o*h,this.z=n*o*h+l*a*r,this.w=n*o*r+l*a*h),this}clone(){return new b(this.x,this.y,this.z,this.w)}slerp(t,e,i){let s,n,o,r,l;void 0===i&&(i=new b);let a=this.x,h=this.y,u=this.z,c=this.w,d=t.x,p=t.y,y=t.z,v=t.w;return(n=a*d+h*p+u*y+c*v)<0&&(n=-n,d=-d,p=-p,y=-y,v=-v),1-n>1e-6?(o=Math.sin(s=Math.acos(n)),r=Math.sin((1-e)*s)/o,l=Math.sin(e*s)/o):(r=1-e,l=e),i.x=r*a+l*d,i.y=r*h+l*p,i.z=r*u+l*y,i.w=r*c+l*v,i}integrate(t,e,i,s){void 0===s&&(s=new b);let n=t.x*i.x,o=t.y*i.y,r=t.z*i.z,l=this.x,a=this.y,h=this.z,u=this.w,c=.5*e;return s.x+=c*(n*u+o*h-r*a),s.y+=c*(o*u+r*l-n*h),s.z+=c*(r*u+n*a-o*l),s.w+=c*(-n*l-o*a-r*h),s}}let E=new d,z=new d;class B{constructor(t){void 0===t&&(t={}),this.id=B.idCounter++,this.type=t.type||0,this.boundingSphereRadius=0,this.collisionResponse=!t.collisionResponse||t.collisionResponse,this.collisionFilterGroup=void 0!==t.collisionFilterGroup?t.collisionFilterGroup:1,this.collisionFilterMask=void 0!==t.collisionFilterMask?t.collisionFilterMask:-1,this.material=t.material?t.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(t,e){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(t,e,i,s){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}B.idCounter=0,B.types={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class S{constructor(t){void 0===t&&(t={}),this.position=new d,this.quaternion=new b,t.position&&this.position.copy(t.position),t.quaternion&&this.quaternion.copy(t.quaternion)}pointToLocal(t,e){return S.pointToLocalFrame(this.position,this.quaternion,t,e)}pointToWorld(t,e){return S.pointToWorldFrame(this.position,this.quaternion,t,e)}vectorToWorldFrame(t,e){return void 0===e&&(e=new d),this.quaternion.vmult(t,e),e}static pointToLocalFrame(t,e,i,s){return void 0===s&&(s=new d),i.vsub(t,s),e.conjugate(A),A.vmult(s,s),s}static pointToWorldFrame(t,e,i,s){return void 0===s&&(s=new d),e.vmult(i,s),s.vadd(t,s),s}static vectorToWorldFrame(t,e,i){return void 0===i&&(i=new d),t.vmult(e,i),i}static vectorToLocalFrame(t,e,i,s){return void 0===s&&(s=new d),e.w*=-1,e.vmult(i,s),e.w*=-1,s}}let A=new b;class C extends B{constructor(t){void 0===t&&(t={});let{vertices:e=[],faces:i=[],normals:s=[],axes:n,boundingSphereRadius:o}=t;super({type:B.types.CONVEXPOLYHEDRON}),this.vertices=e,this.faces=i,this.faceNormals=s,0===this.faceNormals.length&&this.computeNormals(),o?this.boundingSphereRadius=o:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=n?n.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){let t=this.faces,e=this.vertices,i=this.uniqueEdges;i.length=0;let s=new d;for(let n=0;n!==t.length;n++){let o=t[n],r=o.length;for(let t=0;t!==r;t++){let n=(t+1)%r;e[o[t]].vsub(e[o[n]],s),s.normalize();let l=!1;for(let t=0;t!==i.length;t++)if(i[t].almostEquals(s)||i[t].almostEquals(s)){l=!0;break}l||i.push(s.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let t=0;t<this.faces.length;t++){for(let e=0;e<this.faces[t].length;e++)if(!this.vertices[this.faces[t][e]])throw Error(`Vertex ${this.faces[t][e]} not found!`);let e=this.faceNormals[t]||new d;this.getFaceNormal(t,e),e.negate(e),this.faceNormals[t]=e;let i=this.vertices[this.faces[t][0]];if(0>e.dot(i)){console.error(`.faceNormals[${t}] = Vec3(${e.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let e=0;e<this.faces[t].length;e++)console.warn(`.vertices[${this.faces[t][e]}] = Vec3(${this.vertices[this.faces[t][e]].toString()})`)}}}getFaceNormal(t,e){let i=this.faces[t],s=this.vertices[i[0]],n=this.vertices[i[1]],o=this.vertices[i[2]];C.computeNormal(s,n,o,e)}static computeNormal(t,e,i,s){let n=new d,o=new d;e.vsub(t,o),i.vsub(e,n),n.cross(o,s),s.isZero()||s.normalize()}clipAgainstHull(t,e,i,s,n,o,r,l,a){let h=new d,u=-1,c=-Number.MAX_VALUE;for(let t=0;t<i.faces.length;t++){h.copy(i.faceNormals[t]),n.vmult(h,h);let e=h.dot(o);e>c&&(c=e,u=t)}let p=[];for(let t=0;t<i.faces[u].length;t++){let e=i.vertices[i.faces[u][t]],o=new d;o.copy(e),n.vmult(o,o),s.vadd(o,o),p.push(o)}u>=0&&this.clipFaceAgainstHull(o,t,e,p,r,l,a)}findSeparatingAxis(t,e,i,s,n,o,r,l){let a=new d,h=new d,u=new d,c=new d,p=new d,y=new d,v=Number.MAX_VALUE;if(this.uniqueAxes)for(let r=0;r!==this.uniqueAxes.length;r++){i.vmult(this.uniqueAxes[r],a);let l=this.testSepAxis(a,t,e,i,s,n);if(!1===l)return!1;l<v&&(v=l,o.copy(a))}else{let l=r?r.length:this.faces.length;for(let h=0;h<l;h++){let l=r?r[h]:h;a.copy(this.faceNormals[l]),i.vmult(a,a);let u=this.testSepAxis(a,t,e,i,s,n);if(!1===u)return!1;u<v&&(v=u,o.copy(a))}}if(t.uniqueAxes)for(let r=0;r!==t.uniqueAxes.length;r++){n.vmult(t.uniqueAxes[r],h);let l=this.testSepAxis(h,t,e,i,s,n);if(!1===l)return!1;l<v&&(v=l,o.copy(h))}else{let r=l?l.length:t.faces.length;for(let a=0;a<r;a++){let r=l?l[a]:a;h.copy(t.faceNormals[r]),n.vmult(h,h);let u=this.testSepAxis(h,t,e,i,s,n);if(!1===u)return!1;u<v&&(v=u,o.copy(h))}}for(let r=0;r!==this.uniqueEdges.length;r++){i.vmult(this.uniqueEdges[r],c);for(let r=0;r!==t.uniqueEdges.length;r++)if(n.vmult(t.uniqueEdges[r],p),c.cross(p,y),!y.almostZero()){y.normalize();let r=this.testSepAxis(y,t,e,i,s,n);if(!1===r)return!1;r<v&&(v=r,o.copy(y))}}return s.vsub(e,u),u.dot(o)>0&&o.negate(o),!0}testSepAxis(t,e,i,s,n,o){C.project(this,t,i,s,M),C.project(e,t,n,o,F);let r=M[0],l=M[1],a=F[0],h=F[1];if(r<h||a<l)return!1;let u=r-h,c=a-l;return u<c?u:c}calculateLocalInertia(t,e){let i=new d,s=new d;this.computeLocalAABB(s,i);let n=i.x-s.x,o=i.y-s.y,r=i.z-s.z;e.x=1/12*t*(2*o*2*o+2*r*2*r),e.y=1/12*t*(2*n*2*n+2*r*2*r),e.z=1/12*t*(2*o*2*o+2*n*2*n)}getPlaneConstantOfFace(t){let e=this.faces[t],i=this.faceNormals[t],s=this.vertices[e[0]],n=-i.dot(s);return n}clipFaceAgainstHull(t,e,i,s,n,o,r){let l=new d,a=new d,h=new d,u=new d,c=new d,p=new d,y=new d,v=new d,w=[],m=-1,f=Number.MAX_VALUE;for(let e=0;e<this.faces.length;e++){l.copy(this.faceNormals[e]),i.vmult(l,l);let s=l.dot(t);s<f&&(f=s,m=e)}if(m<0)return;let g=this.faces[m];g.connectedFaces=[];for(let t=0;t<this.faces.length;t++)for(let e=0;e<this.faces[t].length;e++)-1!==g.indexOf(this.faces[t][e])&&t!==m&&-1===g.connectedFaces.indexOf(t)&&g.connectedFaces.push(t);let x=g.length;for(let t=0;t<x;t++){let n=this.vertices[g[t]],o=this.vertices[g[(t+1)%x]];n.vsub(o,a),h.copy(a),i.vmult(h,h),e.vadd(h,h),u.copy(this.faceNormals[m]),i.vmult(u,u),e.vadd(u,u),h.cross(u,c),c.negate(c),p.copy(n),i.vmult(p,p),e.vadd(p,p);let r=g.connectedFaces[t];y.copy(this.faceNormals[r]);let l=this.getPlaneConstantOfFace(r);v.copy(y),i.vmult(v,v);let d=l-v.dot(e);for(this.clipFaceAgainstPlane(s,w,v,d);s.length;)s.shift();for(;w.length;)s.push(w.shift())}y.copy(this.faceNormals[m]);let b=this.getPlaneConstantOfFace(m);v.copy(y),i.vmult(v,v);let E=b-v.dot(e);for(let t=0;t<s.length;t++){let e=v.dot(s[t])+E;if(e<=n&&(console.log(`clamped: depth=${e} to minDist=${n}`),e=n),e<=o){let i=s[t];if(e<=1e-6){let t={point:i,normal:v,depth:e};r.push(t)}}}}clipFaceAgainstPlane(t,e,i,s){let n,o;let r=t.length;if(r<2)return e;let l=t[t.length-1],a=t[0];n=i.dot(l)+s;for(let h=0;h<r;h++){if(a=t[h],o=i.dot(a)+s,n<0){if(o<0){let t=new d;t.copy(a),e.push(t)}else{let t=new d;l.lerp(a,n/(n-o),t),e.push(t)}}else if(o<0){let t=new d;l.lerp(a,n/(n-o),t),e.push(t),e.push(a)}l=a,n=o}return e}computeWorldVertices(t,e){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new d);let i=this.vertices,s=this.worldVertices;for(let n=0;n!==this.vertices.length;n++)e.vmult(i[n],s[n]),t.vadd(s[n],s[n]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(t,e){let i=this.vertices;t.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),e.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let s=0;s<this.vertices.length;s++){let n=i[s];n.x<t.x?t.x=n.x:n.x>e.x&&(e.x=n.x),n.y<t.y?t.y=n.y:n.y>e.y&&(e.y=n.y),n.z<t.z?t.z=n.z:n.z>e.z&&(e.z=n.z)}}computeWorldFaceNormals(t){let e=this.faceNormals.length;for(;this.worldFaceNormals.length<e;)this.worldFaceNormals.push(new d);let i=this.faceNormals,s=this.worldFaceNormals;for(let n=0;n!==e;n++)t.vmult(i[n],s[n]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let t=0,e=this.vertices;for(let i=0;i!==e.length;i++){let s=e[i].lengthSquared();s>t&&(t=s)}this.boundingSphereRadius=Math.sqrt(t)}calculateWorldAABB(t,e,i,s){let n,o,r,l,a,h;let u=this.vertices,c=new d;for(let i=0;i<u.length;i++)c.copy(u[i]),e.vmult(c,c),t.vadd(c,c),(void 0===n||c.x<n)&&(n=c.x),(void 0===l||c.x>l)&&(l=c.x),(void 0===o||c.y<o)&&(o=c.y),(void 0===a||c.y>a)&&(a=c.y),(void 0===r||c.z<r)&&(r=c.z),(void 0===h||c.z>h)&&(h=c.z);i.set(n,o,r),s.set(l,a,h)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(t){void 0===t&&(t=new d);let e=this.vertices;for(let i=0;i<e.length;i++)t.vadd(e[i],t);return t.scale(1/e.length,t),t}transformAllPoints(t,e){let i=this.vertices.length,s=this.vertices;if(e){for(let t=0;t<i;t++){let i=s[t];e.vmult(i,i)}for(let t=0;t<this.faceNormals.length;t++){let i=this.faceNormals[t];e.vmult(i,i)}}if(t)for(let e=0;e<i;e++){let i=s[e];i.vadd(t,i)}}pointIsInside(t){let e=this.vertices,i=this.faces,s=this.faceNormals,n=new d;this.getAveragePointLocal(n);for(let o=0;o<this.faces.length;o++){let r=s[o],l=e[i[o][0]],a=new d;t.vsub(l,a);let h=r.dot(a),u=new d;n.vsub(l,u);let c=r.dot(u);if(h<0&&c>0||h>0&&c<0)return!1}return -1}static project(t,e,i,s,n){let o=t.vertices.length,r=0,l=0,a=t.vertices;q.setZero(),S.vectorToLocalFrame(i,s,e,N),S.pointToLocalFrame(i,s,q,q);let h=q.dot(N);l=r=a[0].dot(N);for(let t=1;t<o;t++){let e=a[t].dot(N);e>r&&(r=e),e<l&&(l=e)}if((l-=h)>(r-=h)){let t=l;l=r,r=t}n[0]=r,n[1]=l}}let M=[],F=[];new d;let N=new d,q=new d;class T extends B{constructor(t){super({type:B.types.BOX}),this.halfExtents=t,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){let t=this.halfExtents.x,e=this.halfExtents.y,i=this.halfExtents.z,s=[new d(-t,-e,-i),new d(t,-e,-i),new d(t,e,-i),new d(-t,e,-i),new d(-t,-e,i),new d(t,-e,i),new d(t,e,i),new d(-t,e,i)],n=[new d(0,0,1),new d(0,1,0),new d(1,0,0)],o=new C({vertices:s,faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:n});this.convexPolyhedronRepresentation=o,o.material=this.material}calculateLocalInertia(t,e){return void 0===e&&(e=new d),T.calculateInertia(this.halfExtents,t,e),e}static calculateInertia(t,e,i){i.x=1/12*e*(2*t.y*2*t.y+2*t.z*2*t.z),i.y=1/12*e*(2*t.x*2*t.x+2*t.z*2*t.z),i.z=1/12*e*(2*t.y*2*t.y+2*t.x*2*t.x)}getSideNormals(t,e){let i=this.halfExtents;if(t[0].set(i.x,0,0),t[1].set(0,i.y,0),t[2].set(0,0,i.z),t[3].set(-i.x,0,0),t[4].set(0,-i.y,0),t[5].set(0,0,-i.z),void 0!==e)for(let i=0;i!==t.length;i++)e.vmult(t[i],t[i]);return t}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(t,e,i){let s=this.halfExtents,n=[[s.x,s.y,s.z],[-s.x,s.y,s.z],[-s.x,-s.y,s.z],[-s.x,-s.y,-s.z],[s.x,-s.y,-s.z],[s.x,s.y,-s.z],[-s.x,s.y,-s.z],[s.x,-s.y,s.z]];for(let s=0;s<n.length;s++)R.set(n[s][0],n[s][1],n[s][2]),e.vmult(R,R),t.vadd(R,R),i(R.x,R.y,R.z)}calculateWorldAABB(t,e,i,s){let n=this.halfExtents;P[0].set(n.x,n.y,n.z),P[1].set(-n.x,n.y,n.z),P[2].set(-n.x,-n.y,n.z),P[3].set(-n.x,-n.y,-n.z),P[4].set(n.x,-n.y,-n.z),P[5].set(n.x,n.y,-n.z),P[6].set(-n.x,n.y,-n.z),P[7].set(n.x,-n.y,n.z);let o=P[0];e.vmult(o,o),t.vadd(o,o),s.copy(o),i.copy(o);for(let n=1;n<8;n++){let o=P[n];e.vmult(o,o),t.vadd(o,o);let r=o.x,l=o.y,a=o.z;r>s.x&&(s.x=r),l>s.y&&(s.y=l),a>s.z&&(s.z=a),r<i.x&&(i.x=r),l<i.y&&(i.y=l),a<i.z&&(i.z=a)}}}let R=new d,P=[new d,new d,new d,new d,new d,new d,new d,new d],I={DYNAMIC:1,STATIC:2,KINEMATIC:4},L={AWAKE:0,SLEEPY:1,SLEEPING:2};class j extends x{constructor(t){void 0===t&&(t={}),super(),this.id=j.idCounter++,this.index=-1,this.world=null,this.vlambda=new d,this.collisionFilterGroup="number"==typeof t.collisionFilterGroup?t.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof t.collisionFilterMask?t.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof t.collisionResponse||t.collisionResponse,this.position=new d,this.previousPosition=new d,this.interpolatedPosition=new d,this.initPosition=new d,t.position&&(this.position.copy(t.position),this.previousPosition.copy(t.position),this.interpolatedPosition.copy(t.position),this.initPosition.copy(t.position)),this.velocity=new d,t.velocity&&this.velocity.copy(t.velocity),this.initVelocity=new d,this.force=new d;let e="number"==typeof t.mass?t.mass:0;this.mass=e,this.invMass=e>0?1/e:0,this.material=t.material||null,this.linearDamping="number"==typeof t.linearDamping?t.linearDamping:.01,this.type=e<=0?j.STATIC:j.DYNAMIC,typeof t.type==typeof j.STATIC&&(this.type=t.type),this.allowSleep=void 0===t.allowSleep||t.allowSleep,this.sleepState=j.AWAKE,this.sleepSpeedLimit=void 0!==t.sleepSpeedLimit?t.sleepSpeedLimit:.1,this.sleepTimeLimit=void 0!==t.sleepTimeLimit?t.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new d,this.quaternion=new b,this.initQuaternion=new b,this.previousQuaternion=new b,this.interpolatedQuaternion=new b,t.quaternion&&(this.quaternion.copy(t.quaternion),this.initQuaternion.copy(t.quaternion),this.previousQuaternion.copy(t.quaternion),this.interpolatedQuaternion.copy(t.quaternion)),this.angularVelocity=new d,t.angularVelocity&&this.angularVelocity.copy(t.angularVelocity),this.initAngularVelocity=new d,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new d,this.invInertia=new d,this.invInertiaWorld=new u,this.invMassSolve=0,this.invInertiaSolve=new d,this.invInertiaWorldSolve=new u,this.fixedRotation=void 0!==t.fixedRotation&&t.fixedRotation,this.angularDamping=void 0!==t.angularDamping?t.angularDamping:.01,this.linearFactor=new d(1,1,1),t.linearFactor&&this.linearFactor.copy(t.linearFactor),this.angularFactor=new d(1,1,1),t.angularFactor&&this.angularFactor.copy(t.angularFactor),this.aabb=new w,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new d,this.isTrigger=Boolean(t.isTrigger),t.shape&&this.addShape(t.shape),this.updateMassProperties()}wakeUp(){let t=this.sleepState;this.sleepState=j.AWAKE,this.wakeUpAfterNarrowphase=!1,t===j.SLEEPING&&this.dispatchEvent(j.wakeupEvent)}sleep(){this.sleepState=j.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(t){if(this.allowSleep){let e=this.sleepState,i=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),s=this.sleepSpeedLimit**2;e===j.AWAKE&&i<s?(this.sleepState=j.SLEEPY,this.timeLastSleepy=t,this.dispatchEvent(j.sleepyEvent)):e===j.SLEEPY&&i>s?this.wakeUp():e===j.SLEEPY&&t-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(j.sleepEvent))}}updateSolveMassProperties(){this.sleepState===j.SLEEPING||this.type===j.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(t,e){return void 0===e&&(e=new d),t.vsub(this.position,e),this.quaternion.conjugate().vmult(e,e),e}vectorToLocalFrame(t,e){return void 0===e&&(e=new d),this.quaternion.conjugate().vmult(t,e),e}pointToWorldFrame(t,e){return void 0===e&&(e=new d),this.quaternion.vmult(t,e),e.vadd(this.position,e),e}vectorToWorldFrame(t,e){return void 0===e&&(e=new d),this.quaternion.vmult(t,e),e}addShape(t,e,i){let s=new d,n=new b;return e&&s.copy(e),i&&n.copy(i),this.shapes.push(t),this.shapeOffsets.push(s),this.shapeOrientations.push(n),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=this,this}removeShape(t){let e=this.shapes.indexOf(t);return -1===e?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(e,1),this.shapeOffsets.splice(e,1),this.shapeOrientations.splice(e,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=null,this)}updateBoundingRadius(){let t=this.shapes,e=this.shapeOffsets,i=t.length,s=0;for(let n=0;n!==i;n++){let i=t[n];i.updateBoundingSphereRadius();let o=e[n].length(),r=i.boundingSphereRadius;o+r>s&&(s=o+r)}this.boundingRadius=s}updateAABB(){let t=this.shapes,e=this.shapeOffsets,i=this.shapeOrientations,s=t.length,n=this.quaternion,o=this.aabb;for(let r=0;r!==s;r++){let s=t[r];n.vmult(e[r],V),V.vadd(this.position,V),n.mult(i[r],O),s.calculateWorldAABB(V,O,k.lowerBound,k.upperBound),0===r?o.copy(k):o.extend(k)}this.aabbNeedsUpdate=!1}updateInertiaWorld(t){let e=this.invInertia;(e.x!==e.y||e.y!==e.z||t)&&(W.setRotationFromQuaternion(this.quaternion),W.transpose(H),W.scale(e,W),W.mmult(H,this.invInertiaWorld))}applyForce(t,e){void 0===e&&(e=new d),this.type===j.DYNAMIC&&(this.sleepState===j.SLEEPING&&this.wakeUp(),e.cross(t,D),this.force.vadd(t,this.force),this.torque.vadd(D,this.torque))}applyLocalForce(t,e){void 0===e&&(e=new d),this.type===j.DYNAMIC&&(this.vectorToWorldFrame(t,_),this.vectorToWorldFrame(e,G),this.applyForce(_,G))}applyTorque(t){this.type===j.DYNAMIC&&(this.sleepState===j.SLEEPING&&this.wakeUp(),this.torque.vadd(t,this.torque))}applyImpulse(t,e){if(void 0===e&&(e=new d),this.type!==j.DYNAMIC)return;this.sleepState===j.SLEEPING&&this.wakeUp();let i=e;U.copy(t),U.scale(this.invMass,U),this.velocity.vadd(U,this.velocity),i.cross(t,Y),this.invInertiaWorld.vmult(Y,Y),this.angularVelocity.vadd(Y,this.angularVelocity)}applyLocalImpulse(t,e){void 0===e&&(e=new d),this.type===j.DYNAMIC&&(this.vectorToWorldFrame(t,X),this.vectorToWorldFrame(e,$),this.applyImpulse(X,$))}updateMassProperties(){this.invMass=this.mass>0?1/this.mass:0;let t=this.inertia,e=this.fixedRotation;this.updateAABB(),K.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),T.calculateInertia(K,this.mass,t),this.invInertia.set(t.x>0&&!e?1/t.x:0,t.y>0&&!e?1/t.y:0,t.z>0&&!e?1/t.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(t,e){let i=new d;return t.vsub(this.position,i),this.angularVelocity.cross(i,e),this.velocity.vadd(e,e),e}integrate(t,e,i){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),!(this.type===j.DYNAMIC||this.type===j.KINEMATIC)||this.sleepState===j.SLEEPING)return;let s=this.velocity,n=this.angularVelocity,o=this.position,r=this.force,l=this.torque,a=this.quaternion,h=this.invMass,u=this.invInertiaWorld,c=this.linearFactor,d=h*t;s.x+=r.x*d*c.x,s.y+=r.y*d*c.y,s.z+=r.z*d*c.z;let p=u.elements,y=this.angularFactor,v=l.x*y.x,w=l.y*y.y,m=l.z*y.z;n.x+=t*(p[0]*v+p[1]*w+p[2]*m),n.y+=t*(p[3]*v+p[4]*w+p[5]*m),n.z+=t*(p[6]*v+p[7]*w+p[8]*m),o.x+=s.x*t,o.y+=s.y*t,o.z+=s.z*t,a.integrate(this.angularVelocity,t,this.angularFactor,a),e&&(i?a.normalizeFast():a.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}j.idCounter=0,j.COLLIDE_EVENT_NAME="collide",j.DYNAMIC=I.DYNAMIC,j.STATIC=I.STATIC,j.KINEMATIC=I.KINEMATIC,j.AWAKE=L.AWAKE,j.SLEEPY=L.SLEEPY,j.SLEEPING=L.SLEEPING,j.wakeupEvent={type:"wakeup"},j.sleepyEvent={type:"sleepy"},j.sleepEvent={type:"sleep"};let V=new d,O=new b,k=new w,W=new u,H=new u;new u;let D=new d,_=new d,G=new d,U=new d,Y=new d,X=new d,$=new d,K=new d;class Z{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(t,e,i){throw Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(t,e){return(t.collisionFilterGroup&e.collisionFilterMask)!=0&&(e.collisionFilterGroup&t.collisionFilterMask)!=0&&((t.type&j.STATIC)==0&&t.sleepState!==j.SLEEPING||(e.type&j.STATIC)==0&&e.sleepState!==j.SLEEPING)}intersectionTest(t,e,i,s){this.useBoundingBoxes?this.doBoundingBoxBroadphase(t,e,i,s):this.doBoundingSphereBroadphase(t,e,i,s)}doBoundingSphereBroadphase(t,e,i,s){e.position.vsub(t.position,Q);let n=(t.boundingRadius+e.boundingRadius)**2,o=Q.lengthSquared();o<n&&(i.push(t),s.push(e))}doBoundingBoxBroadphase(t,e,i,s){t.aabbNeedsUpdate&&t.updateAABB(),e.aabbNeedsUpdate&&e.updateAABB(),t.aabb.overlaps(e.aabb)&&(i.push(t),s.push(e))}makePairsUnique(t,e){let i=J,s=tt,n=te,o=t.length;for(let i=0;i!==o;i++)s[i]=t[i],n[i]=e[i];t.length=0,e.length=0;for(let t=0;t!==o;t++){let e=s[t].id,o=n[t].id,r=e<o?`${e},${o}`:`${o},${e}`;i[r]=t,i.keys.push(r)}for(let o=0;o!==i.keys.length;o++){let o=i.keys.pop(),r=i[o];t.push(s[r]),e.push(n[r]),delete i[o]}}setWorld(t){}static boundingSphereCheck(t,e){let i=new d;t.position.vsub(e.position,i);let s=t.shapes[0],n=e.shapes[0];return Math.pow(s.boundingSphereRadius+n.boundingSphereRadius,2)>i.lengthSquared()}aabbQuery(t,e,i){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}let Q=new d;new d,new b,new d;let J={keys:[]},tt=[],te=[];new d,new d,new d;class ti extends Z{constructor(){super()}collisionPairs(t,e,i){let s,n;let o=t.bodies,r=o.length;for(let t=0;t!==r;t++)for(let r=0;r!==t;r++)s=o[t],n=o[r],this.needBroadphaseCollision(s,n)&&this.intersectionTest(s,n,e,i)}aabbQuery(t,e,i){void 0===i&&(i=[]);for(let s=0;s<t.bodies.length;s++){let n=t.bodies[s];n.aabbNeedsUpdate&&n.updateAABB(),n.aabb.overlaps(e)&&i.push(n)}return i}}class ts{constructor(){this.rayFromWorld=new d,this.rayToWorld=new d,this.hitNormalWorld=new d,this.hitPointWorld=new d,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(t,e,i,s,n,o,r){this.rayFromWorld.copy(t),this.rayToWorld.copy(e),this.hitNormalWorld.copy(i),this.hitPointWorld.copy(s),this.shape=n,this.body=o,this.distance=r}}let tn={CLOSEST:1,ANY:2,ALL:4};s=B.types.SPHERE,n=B.types.PLANE,o=B.types.BOX,r=B.types.CYLINDER,l=B.types.CONVEXPOLYHEDRON,a=B.types.HEIGHTFIELD,h=B.types.TRIMESH;class to{get[s](){return this._intersectSphere}get[n](){return this._intersectPlane}get[o](){return this._intersectBox}get[r](){return this._intersectConvex}get[l](){return this._intersectConvex}get[a](){return this._intersectHeightfield}get[h](){return this._intersectTrimesh}constructor(t,e){void 0===t&&(t=new d),void 0===e&&(e=new d),this.from=t.clone(),this.to=e.clone(),this.direction=new d,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=to.ANY,this.result=new ts,this.hasHit=!1,this.callback=t=>{}}intersectWorld(t,e){return this.mode=e.mode||to.ANY,this.result=e.result||new ts,this.skipBackfaces=!!e.skipBackfaces,this.collisionFilterMask=void 0!==e.collisionFilterMask?e.collisionFilterMask:-1,this.collisionFilterGroup=void 0!==e.collisionFilterGroup?e.collisionFilterGroup:-1,this.checkCollisionResponse=void 0===e.checkCollisionResponse||e.checkCollisionResponse,e.from&&this.from.copy(e.from),e.to&&this.to.copy(e.to),this.callback=e.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(tr),tl.length=0,t.broadphase.aabbQuery(t,tr,tl),this.intersectBodies(tl),this.hasHit}intersectBody(t,e){e&&(this.result=e,this.updateDirection());let i=this.checkCollisionResponse;if((!i||t.collisionResponse)&&(this.collisionFilterGroup&t.collisionFilterMask)!=0&&(t.collisionFilterGroup&this.collisionFilterMask)!=0)for(let e=0,s=t.shapes.length;e<s;e++){let s=t.shapes[e];if((!i||s.collisionResponse)&&(t.quaternion.mult(t.shapeOrientations[e],tc),t.quaternion.vmult(t.shapeOffsets[e],tu),tu.vadd(t.position,tu),this.intersectShape(s,tc,tu,t),this.result.shouldStop))break}}intersectBodies(t,e){e&&(this.result=e,this.updateDirection());for(let e=0,i=t.length;!this.result.shouldStop&&e<i;e++)this.intersectBody(t[e])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(t,e,i,s){let n=this.from,o=function(t,e,i){i.vsub(t,tT);let s=tT.dot(e);e.scale(s,tR),tR.vadd(t,tR);let n=i.distanceTo(tR);return n}(n,this.direction,i);if(o>t.boundingSphereRadius)return;let r=this[t.type];r&&r.call(this,t,e,i,s,t)}_intersectBox(t,e,i,s,n){return this._intersectConvex(t.convexPolyhedronRepresentation,e,i,s,n)}_intersectPlane(t,e,i,s,n){let o=this.from,r=this.to,l=this.direction,a=new d(0,0,1);e.vmult(a,a);let h=new d;o.vsub(i,h);let u=h.dot(a);r.vsub(i,h);let c=h.dot(a);if(u*c>0||o.distanceTo(r)<u)return;let p=a.dot(l);if(Math.abs(p)<this.precision)return;let y=new d,v=new d,w=new d;o.vsub(i,y);let m=-a.dot(y)/p;l.scale(m,v),o.vadd(v,w),this.reportIntersection(a,w,n,s,-1)}getAABB(t){let{lowerBound:e,upperBound:i}=t,s=this.to,n=this.from;e.x=Math.min(s.x,n.x),e.y=Math.min(s.y,n.y),e.z=Math.min(s.z,n.z),i.x=Math.max(s.x,n.x),i.y=Math.max(s.y,n.y),i.z=Math.max(s.z,n.z)}_intersectHeightfield(t,e,i,s,n){let o,r,l,a;t.data,t.elementSize,tf.from.copy(this.from),tf.to.copy(this.to),S.pointToLocalFrame(i,e,tf.from,tf.from),S.pointToLocalFrame(i,e,tf.to,tf.to),tf.updateDirection(),o=r=0,l=a=t.data.length-1;let h=new w;tf.getAABB(h),t.getIndexOfPosition(h.lowerBound.x,h.lowerBound.y,tg,!0),o=Math.max(o,tg[0]),r=Math.max(r,tg[1]),t.getIndexOfPosition(h.upperBound.x,h.upperBound.y,tg,!0),l=Math.min(l,tg[0]+1),a=Math.min(a,tg[1]+1);for(let u=o;u<l;u++)for(let o=r;o<a;o++){if(this.result.shouldStop)return;if(t.getAabbAtIndex(u,o,h),h.overlapsRay(tf)){if(t.getConvexTrianglePillar(u,o,!1),S.pointToWorldFrame(i,e,t.pillarOffset,tm),this._intersectConvex(t.pillarConvex,e,tm,s,n,tw),this.result.shouldStop)return;t.getConvexTrianglePillar(u,o,!0),S.pointToWorldFrame(i,e,t.pillarOffset,tm),this._intersectConvex(t.pillarConvex,e,tm,s,n,tw)}}}_intersectSphere(t,e,i,s,n){let o=this.from,r=this.to,l=t.radius,a=(r.x-o.x)**2+(r.y-o.y)**2+(r.z-o.z)**2,h=2*((r.x-o.x)*(o.x-i.x)+(r.y-o.y)*(o.y-i.y)+(r.z-o.z)*(o.z-i.z)),u=(o.x-i.x)**2+(o.y-i.y)**2+(o.z-i.z)**2-l**2,c=h**2-4*a*u;if(!(c<0)){if(0===c)o.lerp(r,c,tx),tx.vsub(i,tb),tb.normalize(),this.reportIntersection(tb,tx,n,s,-1);else{let t=(-h-Math.sqrt(c))/(2*a),e=(-h+Math.sqrt(c))/(2*a);if(t>=0&&t<=1&&(o.lerp(r,t,tx),tx.vsub(i,tb),tb.normalize(),this.reportIntersection(tb,tx,n,s,-1)),this.result.shouldStop)return;e>=0&&e<=1&&(o.lerp(r,e,tx),tx.vsub(i,tb),tb.normalize(),this.reportIntersection(tb,tx,n,s,-1))}}}_intersectConvex(t,e,i,s,n,o){let r=o&&o.faceList||null,l=t.faces,a=t.vertices,h=t.faceNormals,u=this.direction,c=this.from,d=this.to,p=c.distanceTo(d),y=r?r.length:l.length,v=this.result;for(let t=0;!v.shouldStop&&t<y;t++){let o=r?r[t]:t,d=l[o],y=h[o];tz.copy(a[d[0]]),e.vmult(tz,tz),tz.vadd(i,tz),tz.vsub(c,tz),e.vmult(y,tE);let w=u.dot(tE);if(Math.abs(w)<this.precision)continue;let m=tE.dot(tz)/w;if(!(m<0)){u.scale(m,td),td.vadd(c,td),tp.copy(a[d[0]]),e.vmult(tp,tp),i.vadd(tp,tp);for(let t=1;!v.shouldStop&&t<d.length-1;t++){ty.copy(a[d[t]]),tv.copy(a[d[t+1]]),e.vmult(ty,ty),e.vmult(tv,tv),i.vadd(ty,ty),i.vadd(tv,tv);let r=td.distanceTo(c);(to.pointInTriangle(td,tp,ty,tv)||to.pointInTriangle(td,ty,tp,tv))&&!(r>p)&&this.reportIntersection(tE,td,n,s,o)}}}}_intersectTrimesh(t,e,i,s,n,o){let r=tN,l=tA,a=tC,h=t.indices;t.vertices;let u=this.from,c=this.to,d=this.direction;tq.position.copy(i),tq.quaternion.copy(e),S.vectorToLocalFrame(i,e,d,tS),S.pointToLocalFrame(i,e,u,l),S.pointToLocalFrame(i,e,c,a),a.x*=t.scale.x,a.y*=t.scale.y,a.z*=t.scale.z,l.x*=t.scale.x,l.y*=t.scale.y,l.z*=t.scale.z,a.vsub(l,tS),tS.normalize();let p=l.distanceSquared(a);t.tree.rayQuery(this,tq,r);for(let o=0,a=r.length;!this.result.shouldStop&&o!==a;o++){let a=r[o];t.getNormal(a,tB),t.getVertex(h[3*a],tp),tp.vsub(l,tz);let u=tS.dot(tB),c=tB.dot(tz)/u;if(c<0)continue;tS.scale(c,td),td.vadd(l,td),t.getVertex(h[3*a+1],ty),t.getVertex(h[3*a+2],tv);let d=td.distanceSquared(l);(to.pointInTriangle(td,ty,tp,tv)||to.pointInTriangle(td,tp,ty,tv))&&!(d>p)&&(S.vectorToWorldFrame(e,tB,tM),S.pointToWorldFrame(i,e,td,tF),this.reportIntersection(tM,tF,n,s,a))}r.length=0}reportIntersection(t,e,i,s,n){let o=this.from,r=this.to,l=o.distanceTo(e),a=this.result;if(!(this.skipBackfaces&&t.dot(this.direction)>0))switch(a.hitFaceIndex=void 0!==n?n:-1,this.mode){case to.ALL:this.hasHit=!0,a.set(o,r,t,e,i,s,l),a.hasHit=!0,this.callback(a);break;case to.CLOSEST:(l<a.distance||!a.hasHit)&&(this.hasHit=!0,a.hasHit=!0,a.set(o,r,t,e,i,s,l));break;case to.ANY:this.hasHit=!0,a.hasHit=!0,a.set(o,r,t,e,i,s,l),a.shouldStop=!0}}static pointInTriangle(t,e,i,s){let n,o;s.vsub(e,tT),i.vsub(e,ta),t.vsub(e,th);let r=tT.dot(tT),l=tT.dot(ta),a=tT.dot(th),h=ta.dot(ta),u=ta.dot(th);return(n=h*a-l*u)>=0&&(o=r*u-l*a)>=0&&n+o<r*h-l*l}}to.CLOSEST=tn.CLOSEST,to.ANY=tn.ANY,to.ALL=tn.ALL;let tr=new w,tl=[],ta=new d,th=new d,tu=new d,tc=new b,td=new d,tp=new d,ty=new d,tv=new d;new d,new ts;let tw={faceList:[0]},tm=new d,tf=new to,tg=[],tx=new d,tb=new d,tE=new d;new d,new d;let tz=new d,tB=new d,tS=new d,tA=new d,tC=new d,tM=new d,tF=new d;new w;let tN=[],tq=new S,tT=new d,tR=new d;class tP{static defaults(t,e){for(let i in void 0===t&&(t={}),e)i in t||(t[i]=e[i]);return t}}class tI{constructor(t,e,i){void 0===i&&(i={}),i=tP.defaults(i,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=t,this.bodyB=e,this.id=tI.idCounter++,this.collideConnected=i.collideConnected,i.wakeUpBodies&&(t&&t.wakeUp(),e&&e.wakeUp())}update(){throw Error("method update() not implmemented in this Constraint subclass!")}enable(){let t=this.equations;for(let e=0;e<t.length;e++)t[e].enabled=!0}disable(){let t=this.equations;for(let e=0;e<t.length;e++)t[e].enabled=!1}}tI.idCounter=0;class tL{constructor(){this.spatial=new d,this.rotational=new d}multiplyElement(t){return t.spatial.dot(this.spatial)+t.rotational.dot(this.rotational)}multiplyVectors(t,e){return t.dot(this.spatial)+e.dot(this.rotational)}}class tj{constructor(t,e,i,s){void 0===i&&(i=-1e6),void 0===s&&(s=1e6),this.id=tj.idCounter++,this.minForce=i,this.maxForce=s,this.bi=t,this.bj=e,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new tL,this.jacobianElementB=new tL,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(t,e,i){this.a=4/(i*(1+4*e)),this.b=4*e/(1+4*e),this.eps=4/(i*i*t*(1+4*e))}computeB(t,e,i){let s=this.computeGW(),n=this.computeGq(),o=this.computeGiMf();return-n*t-s*e-o*i}computeGq(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,n=i.position,o=s.position;return t.spatial.dot(n)+e.spatial.dot(o)}computeGW(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,n=i.velocity,o=s.velocity,r=i.angularVelocity,l=s.angularVelocity;return t.multiplyVectors(n,r)+e.multiplyVectors(o,l)}computeGWlambda(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,n=i.vlambda,o=s.vlambda,r=i.wlambda,l=s.wlambda;return t.multiplyVectors(n,r)+e.multiplyVectors(o,l)}computeGiMf(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,n=i.force,o=i.torque,r=s.force,l=s.torque,a=i.invMassSolve,h=s.invMassSolve;return n.scale(a,tV),r.scale(h,tO),i.invInertiaWorldSolve.vmult(o,tk),s.invInertiaWorldSolve.vmult(l,tW),t.multiplyVectors(tV,tk)+e.multiplyVectors(tO,tW)}computeGiMGt(){let t=this.jacobianElementA,e=this.jacobianElementB,i=this.bi,s=this.bj,n=i.invMassSolve,o=s.invMassSolve,r=i.invInertiaWorldSolve,l=s.invInertiaWorldSolve,a=n+o;return r.vmult(t.rotational,tH),a+=tH.dot(t.rotational),l.vmult(e.rotational,tH),a+=tH.dot(e.rotational)}addToWlambda(t){let e=this.jacobianElementA,i=this.jacobianElementB,s=this.bi,n=this.bj;s.vlambda.addScaledVector(s.invMassSolve*t,e.spatial,s.vlambda),n.vlambda.addScaledVector(n.invMassSolve*t,i.spatial,n.vlambda),s.invInertiaWorldSolve.vmult(e.rotational,tD),s.wlambda.addScaledVector(t,tD,s.wlambda),n.invInertiaWorldSolve.vmult(i.rotational,tD),n.wlambda.addScaledVector(t,tD,n.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}tj.idCounter=0;let tV=new d,tO=new d,tk=new d,tW=new d,tH=new d,tD=new d;class t_ extends tj{constructor(t,e,i){void 0===i&&(i=1e6),super(t,e,0,i),this.restitution=0,this.ri=new d,this.rj=new d,this.ni=new d}computeB(t){let e=this.a,i=this.b,s=this.bi,n=this.bj,o=this.ri,r=this.rj,l=s.velocity,a=s.angularVelocity;s.force,s.torque;let h=n.velocity,u=n.angularVelocity;n.force,n.torque;let c=this.jacobianElementA,d=this.jacobianElementB,p=this.ni;o.cross(p,tG),r.cross(p,tU),p.negate(c.spatial),tG.negate(c.rotational),d.spatial.copy(p),d.rotational.copy(tU),tY.copy(n.position),tY.vadd(r,tY),tY.vsub(s.position,tY),tY.vsub(o,tY);let y=p.dot(tY),v=this.restitution+1,w=v*h.dot(p)-v*l.dot(p)+u.dot(tU)-a.dot(tG),m=this.computeGiMf();return-y*e-w*i-t*m}getImpactVelocityAlongNormal(){return this.bi.position.vadd(this.ri,tK),this.bj.position.vadd(this.rj,tZ),this.bi.getVelocityAtWorldPoint(tK,tX),this.bj.getVelocityAtWorldPoint(tZ,t$),tX.vsub(t$,tQ),this.ni.dot(tQ)}}let tG=new d,tU=new d,tY=new d,tX=new d,t$=new d,tK=new d,tZ=new d,tQ=new d;new d,new d,new d,new d,new d,new d,new d,new d,new d,new d;class tJ extends tj{constructor(t,e,i){super(t,e,-i,i),this.ri=new d,this.rj=new d,this.t=new d}computeB(t){this.a;let e=this.b;this.bi,this.bj;let i=this.ri,s=this.rj,n=this.t;i.cross(n,t0),s.cross(n,t1);let o=this.jacobianElementA,r=this.jacobianElementB;n.negate(o.spatial),t0.negate(o.rotational),r.spatial.copy(n),r.rotational.copy(t1);let l=this.computeGW(),a=this.computeGiMf();return-l*e-t*a}}let t0=new d,t1=new d;class t2{constructor(t,e,i){i=tP.defaults(i,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=t2.idCounter++,this.materials=[t,e],this.friction=i.friction,this.restitution=i.restitution,this.contactEquationStiffness=i.contactEquationStiffness,this.contactEquationRelaxation=i.contactEquationRelaxation,this.frictionEquationStiffness=i.frictionEquationStiffness,this.frictionEquationRelaxation=i.frictionEquationRelaxation}}t2.idCounter=0;class t3{constructor(t){void 0===t&&(t={});let e="";"string"==typeof t&&(e=t,t={}),this.name=e,this.id=t3.idCounter++,this.friction=void 0!==t.friction?t.friction:-1,this.restitution=void 0!==t.restitution?t.restitution:-1}}t3.idCounter=0,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new to,new d,new d,new d,new d(1,0,0),new d(0,1,0),new d(0,0,1),new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d,new d;class t6 extends B{constructor(){super({type:B.types.PLANE}),this.worldNormal=new d,this.worldNormalNeedsUpdate=!0,this.boundingSphereRadius=Number.MAX_VALUE}computeWorldNormal(t){let e=this.worldNormal;e.set(0,0,1),t.vmult(e,e),this.worldNormalNeedsUpdate=!1}calculateLocalInertia(t,e){return void 0===e&&(e=new d),e}volume(){return Number.MAX_VALUE}calculateWorldAABB(t,e,i,s){t4.set(0,0,1),e.vmult(t4,t4);let n=Number.MAX_VALUE;i.set(-n,-n,-n),s.set(n,n,n),1===t4.x?s.x=t.x:-1===t4.x&&(i.x=t.x),1===t4.y?s.y=t.y:-1===t4.y&&(i.y=t.y),1===t4.z?s.z=t.z:-1===t4.z&&(i.z=t.z)}updateBoundingSphereRadius(){this.boundingSphereRadius=Number.MAX_VALUE}}let t4=new d;new d,new d,new d,new d,new d,new d,new d,new d,new d;class t5{constructor(t){void 0===t&&(t={}),this.root=t.root||null,this.aabb=t.aabb?t.aabb.clone():new w,this.data=[],this.children=[]}reset(){this.children.length=this.data.length=0}insert(t,e,i){void 0===i&&(i=0);let s=this.data;if(!this.aabb.contains(t))return!1;let n=this.children,o=this.maxDepth||this.root.maxDepth;if(i<o){let s=!1;n.length||(this.subdivide(),s=!0);for(let s=0;8!==s;s++)if(n[s].insert(t,e,i+1))return!0;s&&(n.length=0)}return s.push(e),!0}subdivide(){let t=this.aabb,e=t.lowerBound,i=t.upperBound,s=this.children;s.push(new t5({aabb:new w({lowerBound:new d(0,0,0)})}),new t5({aabb:new w({lowerBound:new d(1,0,0)})}),new t5({aabb:new w({lowerBound:new d(1,1,0)})}),new t5({aabb:new w({lowerBound:new d(1,1,1)})}),new t5({aabb:new w({lowerBound:new d(0,1,1)})}),new t5({aabb:new w({lowerBound:new d(0,0,1)})}),new t5({aabb:new w({lowerBound:new d(1,0,1)})}),new t5({aabb:new w({lowerBound:new d(0,1,0)})})),i.vsub(e,t8),t8.scale(.5,t8);let n=this.root||this;for(let t=0;8!==t;t++){let i=s[t];i.root=n;let o=i.aabb.lowerBound;o.x*=t8.x,o.y*=t8.y,o.z*=t8.z,o.vadd(e,o),o.vadd(t8,i.aabb.upperBound)}}aabbQuery(t,e){this.data,this.children;let i=[this];for(;i.length;){let s=i.pop();s.aabb.overlaps(t)&&Array.prototype.push.apply(e,s.data),Array.prototype.push.apply(i,s.children)}return e}rayQuery(t,e,i){return t.getAABB(t9),t9.toLocalFrame(e,t9),this.aabbQuery(t9,i),i}removeEmptyNodes(){for(let t=this.children.length-1;t>=0;t--)this.children[t].removeEmptyNodes(),this.children[t].children.length||this.children[t].data.length||this.children.splice(t,1)}}class t7 extends t5{constructor(t,e){void 0===e&&(e={}),super({root:null,aabb:t}),this.maxDepth=void 0!==e.maxDepth?e.maxDepth:8}}let t8=new d,t9=new w;class et extends B{constructor(t,e){super({type:B.types.TRIMESH}),this.vertices=new Float32Array(t),this.indices=new Int16Array(e),this.normals=new Float32Array(e.length),this.aabb=new w,this.edges=null,this.scale=new d(1,1,1),this.tree=new t7,this.updateEdges(),this.updateNormals(),this.updateAABB(),this.updateBoundingSphereRadius(),this.updateTree()}updateTree(){let t=this.tree;t.reset(),t.aabb.copy(this.aabb);let e=this.scale;t.aabb.lowerBound.x*=1/e.x,t.aabb.lowerBound.y*=1/e.y,t.aabb.lowerBound.z*=1/e.z,t.aabb.upperBound.x*=1/e.x,t.aabb.upperBound.y*=1/e.y,t.aabb.upperBound.z*=1/e.z;let i=new w,s=new d,n=new d,o=new d,r=[s,n,o];for(let e=0;e<this.indices.length/3;e++){let l=3*e;this._getUnscaledVertex(this.indices[l],s),this._getUnscaledVertex(this.indices[l+1],n),this._getUnscaledVertex(this.indices[l+2],o),i.setFromPoints(r),t.insert(i,e)}t.removeEmptyNodes()}getTrianglesInAABB(t,e){ei.copy(t);let i=this.scale,s=i.x,n=i.y,o=i.z,r=ei.lowerBound,l=ei.upperBound;return r.x/=s,r.y/=n,r.z/=o,l.x/=s,l.y/=n,l.z/=o,this.tree.aabbQuery(ei,e)}setScale(t){let e=this.scale.x===this.scale.y&&this.scale.y===this.scale.z,i=t.x===t.y&&t.y===t.z;e&&i||this.updateNormals(),this.scale.copy(t),this.updateAABB(),this.updateBoundingSphereRadius()}updateNormals(){let t=this.normals;for(let e=0;e<this.indices.length/3;e++){let i=3*e,s=this.indices[i],n=this.indices[i+1],o=this.indices[i+2];this.getVertex(s,el),this.getVertex(n,ea),this.getVertex(o,eh),et.computeNormal(ea,el,eh,ee),t[i]=ee.x,t[i+1]=ee.y,t[i+2]=ee.z}}updateEdges(){let t={},e=(e,i)=>{let s=e<i?`${e}_${i}`:`${i}_${e}`;t[s]=!0};for(let t=0;t<this.indices.length/3;t++){let i=3*t,s=this.indices[i],n=this.indices[i+1],o=this.indices[i+2];e(s,n),e(n,o),e(o,s)}let i=Object.keys(t);this.edges=new Int16Array(2*i.length);for(let t=0;t<i.length;t++){let e=i[t].split("_");this.edges[2*t]=parseInt(e[0],10),this.edges[2*t+1]=parseInt(e[1],10)}}getEdgeVertex(t,e,i){let s=this.edges[2*t+(e?1:0)];this.getVertex(s,i)}getEdgeVector(t,e){this.getEdgeVertex(t,0,es),this.getEdgeVertex(t,1,en),en.vsub(es,e)}static computeNormal(t,e,i,s){e.vsub(t,er),i.vsub(e,eo),eo.cross(er,s),s.isZero()||s.normalize()}getVertex(t,e){let i=this.scale;return this._getUnscaledVertex(t,e),e.x*=i.x,e.y*=i.y,e.z*=i.z,e}_getUnscaledVertex(t,e){let i=3*t,s=this.vertices;return e.set(s[i],s[i+1],s[i+2])}getWorldVertex(t,e,i,s){return this.getVertex(t,s),S.pointToWorldFrame(e,i,s,s),s}getTriangleVertices(t,e,i,s){let n=3*t;this.getVertex(this.indices[n],e),this.getVertex(this.indices[n+1],i),this.getVertex(this.indices[n+2],s)}getNormal(t,e){let i=3*t;return e.set(this.normals[i],this.normals[i+1],this.normals[i+2])}calculateLocalInertia(t,e){this.computeLocalAABB(eu);let i=eu.upperBound.x-eu.lowerBound.x,s=eu.upperBound.y-eu.lowerBound.y,n=eu.upperBound.z-eu.lowerBound.z;return e.set(1/12*t*(2*s*2*s+2*n*2*n),1/12*t*(2*i*2*i+2*n*2*n),1/12*t*(2*s*2*s+2*i*2*i))}computeLocalAABB(t){let e=t.lowerBound,i=t.upperBound,s=this.vertices.length;this.vertices,this.getVertex(0,ec),e.copy(ec),i.copy(ec);for(let t=0;t!==s;t++)this.getVertex(t,ec),ec.x<e.x?e.x=ec.x:ec.x>i.x&&(i.x=ec.x),ec.y<e.y?e.y=ec.y:ec.y>i.y&&(i.y=ec.y),ec.z<e.z?e.z=ec.z:ec.z>i.z&&(i.z=ec.z)}updateAABB(){this.computeLocalAABB(this.aabb)}updateBoundingSphereRadius(){let t=0,e=this.vertices,i=new d;for(let s=0,n=e.length/3;s!==n;s++){this.getVertex(s,i);let e=i.lengthSquared();e>t&&(t=e)}this.boundingSphereRadius=Math.sqrt(t)}calculateWorldAABB(t,e,i,s){let n=ed;n.position=t,n.quaternion=e,this.aabb.toWorldFrame(n,ep),i.copy(ep.lowerBound),s.copy(ep.upperBound)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}static createTorus(t,e,i,s,n){void 0===t&&(t=1),void 0===e&&(e=.5),void 0===i&&(i=8),void 0===s&&(s=6),void 0===n&&(n=2*Math.PI);let o=[],r=[];for(let r=0;r<=i;r++)for(let l=0;l<=s;l++){let a=l/s*n,h=r/i*Math.PI*2,u=(t+e*Math.cos(h))*Math.cos(a),c=(t+e*Math.cos(h))*Math.sin(a),d=e*Math.sin(h);o.push(u,c,d)}for(let t=1;t<=i;t++)for(let e=1;e<=s;e++){let i=(s+1)*t+e-1,n=(s+1)*(t-1)+e-1,o=(s+1)*(t-1)+e,l=(s+1)*t+e;r.push(i,n,l),r.push(n,o,l)}return new et(o,r)}}let ee=new d,ei=new w,es=new d,en=new d,eo=new d,er=new d,el=new d,ea=new d,eh=new d,eu=new w,ec=new d,ed=new S,ep=new w;class ey{constructor(){this.equations=[]}solve(t,e){return 0}addEquation(t){!t.enabled||t.bi.isTrigger||t.bj.isTrigger||this.equations.push(t)}removeEquation(t){let e=this.equations,i=e.indexOf(t);-1!==i&&e.splice(i,1)}removeAllEquations(){this.equations.length=0}}class ev extends ey{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(t,e){let i,s,n,o,r,l=0,a=this.iterations,h=this.tolerance*this.tolerance,u=this.equations,c=u.length,d=e.bodies,p=d.length;if(0!==c)for(let t=0;t!==p;t++)d[t].updateSolveMassProperties();let y=em,v=ef,w=ew;y.length=c,v.length=c,w.length=c;for(let e=0;e!==c;e++){let i=u[e];w[e]=0,v[e]=i.computeB(t),y[e]=1/i.computeC()}if(0!==c){for(let t=0;t!==p;t++){let e=d[t],i=e.vlambda,s=e.wlambda;i.set(0,0,0),s.set(0,0,0)}for(l=0;l!==a;l++){o=0;for(let t=0;t!==c;t++){let e=u[t];i=v[t],s=y[t],r=w[t],n=s*(i-e.computeGWlambda()-e.eps*r),r+n<e.minForce?n=e.minForce-r:r+n>e.maxForce&&(n=e.maxForce-r),w[t]+=n,o+=n>0?n:-n,e.addToWlambda(n)}if(o*o<h)break}for(let t=0;t!==p;t++){let e=d[t],i=e.velocity,s=e.angularVelocity;e.vlambda.vmul(e.linearFactor,e.vlambda),i.vadd(e.vlambda,i),e.wlambda.vmul(e.angularFactor,e.wlambda),s.vadd(e.wlambda,s)}let e=u.length,m=1/t;for(;e--;)u[e].multiplier=w[e]*m}return l}}let ew=[],em=[],ef=[];j.STATIC;class eg{constructor(){this.objects=[],this.type=Object}release(){let t=arguments.length;for(let e=0;e!==t;e++)this.objects.push(e<0||arguments.length<=e?void 0:arguments[e]);return this}get(){return 0===this.objects.length?this.constructObject():this.objects.pop()}constructObject(){throw Error("constructObject() not implemented in this Pool subclass yet!")}resize(t){let e=this.objects;for(;e.length>t;)e.pop();for(;e.length<t;)e.push(this.constructObject());return this}}class ex extends eg{constructor(){super(...arguments),this.type=d}constructObject(){return new d}}let eb={sphereSphere:B.types.SPHERE,spherePlane:B.types.SPHERE|B.types.PLANE,boxBox:B.types.BOX|B.types.BOX,sphereBox:B.types.SPHERE|B.types.BOX,planeBox:B.types.PLANE|B.types.BOX,convexConvex:B.types.CONVEXPOLYHEDRON,sphereConvex:B.types.SPHERE|B.types.CONVEXPOLYHEDRON,planeConvex:B.types.PLANE|B.types.CONVEXPOLYHEDRON,boxConvex:B.types.BOX|B.types.CONVEXPOLYHEDRON,sphereHeightfield:B.types.SPHERE|B.types.HEIGHTFIELD,boxHeightfield:B.types.BOX|B.types.HEIGHTFIELD,convexHeightfield:B.types.CONVEXPOLYHEDRON|B.types.HEIGHTFIELD,sphereParticle:B.types.PARTICLE|B.types.SPHERE,planeParticle:B.types.PLANE|B.types.PARTICLE,boxParticle:B.types.BOX|B.types.PARTICLE,convexParticle:B.types.PARTICLE|B.types.CONVEXPOLYHEDRON,cylinderCylinder:B.types.CYLINDER,sphereCylinder:B.types.SPHERE|B.types.CYLINDER,planeCylinder:B.types.PLANE|B.types.CYLINDER,boxCylinder:B.types.BOX|B.types.CYLINDER,convexCylinder:B.types.CONVEXPOLYHEDRON|B.types.CYLINDER,heightfieldCylinder:B.types.HEIGHTFIELD|B.types.CYLINDER,particleCylinder:B.types.PARTICLE|B.types.CYLINDER,sphereTrimesh:B.types.SPHERE|B.types.TRIMESH,planeTrimesh:B.types.PLANE|B.types.TRIMESH};class eE{get[eb.sphereSphere](){return this.sphereSphere}get[eb.spherePlane](){return this.spherePlane}get[eb.boxBox](){return this.boxBox}get[eb.sphereBox](){return this.sphereBox}get[eb.planeBox](){return this.planeBox}get[eb.convexConvex](){return this.convexConvex}get[eb.sphereConvex](){return this.sphereConvex}get[eb.planeConvex](){return this.planeConvex}get[eb.boxConvex](){return this.boxConvex}get[eb.sphereHeightfield](){return this.sphereHeightfield}get[eb.boxHeightfield](){return this.boxHeightfield}get[eb.convexHeightfield](){return this.convexHeightfield}get[eb.sphereParticle](){return this.sphereParticle}get[eb.planeParticle](){return this.planeParticle}get[eb.boxParticle](){return this.boxParticle}get[eb.convexParticle](){return this.convexParticle}get[eb.cylinderCylinder](){return this.convexConvex}get[eb.sphereCylinder](){return this.sphereConvex}get[eb.planeCylinder](){return this.planeConvex}get[eb.boxCylinder](){return this.boxConvex}get[eb.convexCylinder](){return this.convexConvex}get[eb.heightfieldCylinder](){return this.heightfieldCylinder}get[eb.particleCylinder](){return this.particleCylinder}get[eb.sphereTrimesh](){return this.sphereTrimesh}get[eb.planeTrimesh](){return this.planeTrimesh}constructor(t){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new ex,this.world=t,this.currentContactMaterial=t.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(t,e,i,s,n,o){let r;this.contactPointPool.length?((r=this.contactPointPool.pop()).bi=t,r.bj=e):r=new t_(t,e),r.enabled=t.collisionResponse&&e.collisionResponse&&i.collisionResponse&&s.collisionResponse;let l=this.currentContactMaterial;r.restitution=l.restitution,r.setSpookParams(l.contactEquationStiffness,l.contactEquationRelaxation,this.world.dt);let a=i.material||t.material,h=s.material||e.material;return a&&h&&a.restitution>=0&&h.restitution>=0&&(r.restitution=a.restitution*h.restitution),r.si=n||i,r.sj=o||s,r}createFrictionEquationsFromContact(t,e){let i=t.bi,s=t.bj,n=t.si,o=t.sj,r=this.world,l=this.currentContactMaterial,a=l.friction,h=n.material||i.material,u=o.material||s.material;if(h&&u&&h.friction>=0&&u.friction>=0&&(a=h.friction*u.friction),a>0){let n=a*(r.frictionGravity||r.gravity).length(),o=i.invMass+s.invMass;o>0&&(o=1/o);let h=this.frictionEquationPool,u=h.length?h.pop():new tJ(i,s,n*o),c=h.length?h.pop():new tJ(i,s,n*o);return u.bi=c.bi=i,u.bj=c.bj=s,u.minForce=c.minForce=-n*o,u.maxForce=c.maxForce=n*o,u.ri.copy(t.ri),u.rj.copy(t.rj),c.ri.copy(t.ri),c.rj.copy(t.rj),t.ni.tangents(u.t,c.t),u.setSpookParams(l.frictionEquationStiffness,l.frictionEquationRelaxation,r.dt),c.setSpookParams(l.frictionEquationStiffness,l.frictionEquationRelaxation,r.dt),u.enabled=c.enabled=t.enabled,e.push(u,c),!0}return!1}createFrictionFromAverage(t){let e=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(e,this.frictionResult)||1===t)return;let i=this.frictionResult[this.frictionResult.length-2],s=this.frictionResult[this.frictionResult.length-1];ez.setZero(),eB.setZero(),eS.setZero();let n=e.bi;e.bj;for(let i=0;i!==t;i++)(e=this.result[this.result.length-1-i]).bi!==n?(ez.vadd(e.ni,ez),eB.vadd(e.ri,eB),eS.vadd(e.rj,eS)):(ez.vsub(e.ni,ez),eB.vadd(e.rj,eB),eS.vadd(e.ri,eS));let o=1/t;eB.scale(o,i.ri),eS.scale(o,i.rj),s.ri.copy(i.ri),s.rj.copy(i.rj),ez.normalize(),ez.tangents(i.t,s.t)}getContacts(t,e,i,s,n,o,r){this.contactPointPool=n,this.frictionEquationPool=r,this.result=s,this.frictionResult=o;for(let s=0,n=t.length;s!==n;s++){let n=t[s],o=e[s],r=null;n.material&&o.material&&(r=i.getContactMaterial(n.material,o.material)||null);let l=n.type&j.KINEMATIC&&o.type&j.STATIC||n.type&j.STATIC&&o.type&j.KINEMATIC||n.type&j.KINEMATIC&&o.type&j.KINEMATIC;for(let t=0;t<n.shapes.length;t++){n.quaternion.mult(n.shapeOrientations[t],eM),n.quaternion.vmult(n.shapeOffsets[t],eA),eA.vadd(n.position,eA);let e=n.shapes[t];for(let t=0;t<o.shapes.length;t++){o.quaternion.mult(o.shapeOrientations[t],eF),o.quaternion.vmult(o.shapeOffsets[t],eC),eC.vadd(o.position,eC);let s=o.shapes[t];if(!(e.collisionFilterMask&s.collisionFilterGroup&&s.collisionFilterMask&e.collisionFilterGroup)||eA.distanceTo(eC)>e.boundingSphereRadius+s.boundingSphereRadius)continue;let a=null;e.material&&s.material&&(a=i.getContactMaterial(e.material,s.material)||null),this.currentContactMaterial=a||r||i.defaultContactMaterial;let h=e.type|s.type,u=this[h];u&&(e.type<s.type?u.call(this,e,s,eA,eC,eM,eF,n,o,e,s,l):u.call(this,s,e,eC,eA,eF,eM,o,n,e,s,l))&&l&&(i.shapeOverlapKeeper.set(e.id,s.id),i.bodyOverlapKeeper.set(n.id,o.id))}}}}sphereSphere(t,e,i,s,n,o,r,l,a,h,u){if(u)return i.distanceSquared(s)<(t.radius+e.radius)**2;let c=this.createContactEquation(r,l,t,e,a,h);s.vsub(i,c.ni),c.ni.normalize(),c.ri.copy(c.ni),c.rj.copy(c.ni),c.ri.scale(t.radius,c.ri),c.rj.scale(-e.radius,c.rj),c.ri.vadd(i,c.ri),c.ri.vsub(r.position,c.ri),c.rj.vadd(s,c.rj),c.rj.vsub(l.position,c.rj),this.result.push(c),this.createFrictionEquationsFromContact(c,this.frictionResult)}spherePlane(t,e,i,s,n,o,r,l,a,h,u){let c=this.createContactEquation(r,l,t,e,a,h);if(c.ni.set(0,0,1),o.vmult(c.ni,c.ni),c.ni.negate(c.ni),c.ni.normalize(),c.ni.scale(t.radius,c.ri),i.vsub(s,eX),c.ni.scale(c.ni.dot(eX),e$),eX.vsub(e$,c.rj),-eX.dot(c.ni)<=t.radius){if(u)return!0;let t=c.ri,e=c.rj;t.vadd(i,t),t.vsub(r.position,t),e.vadd(s,e),e.vsub(l.position,e),this.result.push(c),this.createFrictionEquationsFromContact(c,this.frictionResult)}}boxBox(t,e,i,s,n,o,r,l,a,h,u){return t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e.convexPolyhedronRepresentation,i,s,n,o,r,l,t,e,u)}sphereBox(t,e,i,s,n,o,r,l,a,h,u){let c=this.v3pool;i.vsub(s,eJ),e.getSideNormals(e3,o);let d=t.radius,p=!1,y=null,v=0,w=0,m=0,f=null;for(let t=0,e=e3.length;t!==e&&!1===p;t++){e0.copy(e3[t]);let e=e0.length();e0.normalize();let i=eJ.dot(e0);if(i<e+d&&i>0){e1.copy(e3[(t+1)%3]),e2.copy(e3[(t+2)%3]);let s=e1.length(),n=e2.length();e1.normalize(),e2.normalize();let o=eJ.dot(e1),r=eJ.dot(e2);if(o<s&&o>-s&&r<n&&r>-n){let t=Math.abs(i-e-d);if((null===f||t<f)&&(f=t,w=o,m=r,y=e,e4.copy(e0),e5.copy(e1),e7.copy(e2),v++,u))return!0}}}if(v){p=!0;let n=this.createContactEquation(r,l,t,e,a,h);e4.scale(-d,n.ri),n.ni.copy(e4),n.ni.negate(n.ni),e4.scale(y,e4),e5.scale(w,e5),e4.vadd(e5,e4),e7.scale(m,e7),e4.vadd(e7,n.rj),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),n.rj.vadd(s,n.rj),n.rj.vsub(l.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}let g=c.get();for(let n=0;2!==n&&!p;n++)for(let o=0;2!==o&&!p;o++)for(let c=0;2!==c&&!p;c++)if(g.set(0,0,0),n?g.vadd(e3[0],g):g.vsub(e3[0],g),o?g.vadd(e3[1],g):g.vsub(e3[1],g),c?g.vadd(e3[2],g):g.vsub(e3[2],g),s.vadd(g,e6),e6.vsub(i,e6),e6.lengthSquared()<d*d){if(u)return!0;p=!0;let n=this.createContactEquation(r,l,t,e,a,h);n.ri.copy(e6),n.ri.normalize(),n.ni.copy(n.ri),n.ri.scale(d,n.ri),n.rj.copy(g),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),n.rj.vadd(s,n.rj),n.rj.vsub(l.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}c.release(g),g=null;let x=c.get(),b=c.get(),E=c.get(),z=c.get(),B=c.get(),S=e3.length;for(let n=0;n!==S&&!p;n++)for(let o=0;o!==S&&!p;o++)if(n%3!=o%3){e3[o].cross(e3[n],x),x.normalize(),e3[n].vadd(e3[o],b),E.copy(i),E.vsub(b,E),E.vsub(s,E);let c=E.dot(x);x.scale(c,z);let y=0;for(;y===n%3||y===o%3;)y++;B.copy(i),B.vsub(z,B),B.vsub(b,B),B.vsub(s,B);let v=Math.abs(c),w=B.length();if(v<e3[y].length()&&w<d){if(u)return!0;p=!0;let n=this.createContactEquation(r,l,t,e,a,h);b.vadd(z,n.rj),n.rj.copy(n.rj),B.negate(n.ni),n.ni.normalize(),n.ri.copy(n.rj),n.ri.vadd(s,n.ri),n.ri.vsub(i,n.ri),n.ri.normalize(),n.ri.scale(d,n.ri),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),n.rj.vadd(s,n.rj),n.rj.vsub(l.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}c.release(x,b,E,z,B)}planeBox(t,e,i,s,n,o,r,l,a,h,u){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,e.convexPolyhedronRepresentation.id=e.id,this.planeConvex(t,e.convexPolyhedronRepresentation,i,s,n,o,r,l,t,e,u)}convexConvex(t,e,i,s,n,o,r,l,a,h,u,c,d){if(!(i.distanceTo(s)>t.boundingSphereRadius+e.boundingSphereRadius)&&t.findSeparatingAxis(e,i,n,s,o,ip,c,d)){let c=[];t.clipAgainstHull(i,n,e,s,o,ip,-100,100,c);let d=0;for(let n=0;n!==c.length;n++){if(u)return!0;let o=this.createContactEquation(r,l,t,e,a,h),p=o.ri,y=o.rj;ip.negate(o.ni),c[n].normal.negate(iy),iy.scale(c[n].depth,iy),c[n].point.vadd(iy,p),y.copy(c[n].point),p.vsub(i,p),y.vsub(s,y),p.vadd(i,p),p.vsub(r.position,p),y.vadd(s,y),y.vsub(l.position,y),this.result.push(o),d++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(o,this.frictionResult)}this.enableFrictionReduction&&d&&this.createFrictionFromAverage(d)}}sphereConvex(t,e,i,s,n,o,r,l,a,h,u){let c=this.v3pool;i.vsub(s,e8);let d=e.faceNormals,p=e.faces,y=e.vertices,v=t.radius,w=!1;for(let n=0;n!==y.length;n++){let c=y[n];if(o.vmult(c,ii),s.vadd(ii,ii),ii.vsub(i,ie),ie.lengthSquared()<v*v){if(u)return!0;w=!0;let n=this.createContactEquation(r,l,t,e,a,h);n.ri.copy(ie),n.ri.normalize(),n.ni.copy(n.ri),n.ri.scale(v,n.ri),ii.vsub(s,n.rj),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),n.rj.vadd(s,n.rj),n.rj.vsub(l.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult);return}}for(let n=0,m=p.length;n!==m&&!1===w;n++){let m=d[n],f=p[n];o.vmult(m,is),o.vmult(y[f[0]],io),io.vadd(s,io),is.scale(-v,ir),i.vadd(ir,ir),ir.vsub(io,il);let g=il.dot(is);if(i.vsub(io,ia),g<0&&ia.dot(is)>0){let n=[];for(let t=0,e=f.length;t!==e;t++){let e=c.get();o.vmult(y[f[t]],e),s.vadd(e,e),n.push(e)}if(function(t,e,i){let s=null,n=t.length;for(let o=0;o!==n;o++){let r=t[o];t[(o+1)%n].vsub(r,eK),eK.cross(e,eZ),i.vsub(r,eQ);let l=eZ.dot(eQ);if(null!==s&&(!(l>0)||!0!==s)&&(!(l<=0)||!1!==s))return!1;null===s&&(s=l>0)}return!0}(n,is,i)){if(u)return!0;w=!0;let o=this.createContactEquation(r,l,t,e,a,h);is.scale(-v,o.ri),is.negate(o.ni);let d=c.get();is.scale(-g,d);let p=c.get();is.scale(-v,p),i.vsub(s,o.rj),o.rj.vadd(p,o.rj),o.rj.vadd(d,o.rj),o.rj.vadd(s,o.rj),o.rj.vsub(l.position,o.rj),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),c.release(d),c.release(p),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult);for(let t=0,e=n.length;t!==e;t++)c.release(n[t]);return}for(let d=0;d!==f.length;d++){let p=c.get(),w=c.get();o.vmult(y[f[(d+1)%f.length]],p),o.vmult(y[f[(d+2)%f.length]],w),s.vadd(p,p),s.vadd(w,w),w.vsub(p,e9),e9.unit(it);let m=c.get(),g=c.get();i.vsub(p,g);let x=g.dot(it);it.scale(x,m),m.vadd(p,m);let b=c.get();if(m.vsub(i,b),x>0&&x*x<e9.lengthSquared()&&b.lengthSquared()<v*v){if(u)return!0;let o=this.createContactEquation(r,l,t,e,a,h);m.vsub(s,o.rj),m.vsub(i,o.ni),o.ni.normalize(),o.ni.scale(v,o.ri),o.rj.vadd(s,o.rj),o.rj.vsub(l.position,o.rj),o.ri.vadd(i,o.ri),o.ri.vsub(r.position,o.ri),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult);for(let t=0,e=n.length;t!==e;t++)c.release(n[t]);c.release(p),c.release(w),c.release(m),c.release(b),c.release(g);return}c.release(p),c.release(w),c.release(m),c.release(b),c.release(g)}for(let t=0,e=n.length;t!==e;t++)c.release(n[t])}}}planeConvex(t,e,i,s,n,o,r,l,a,h,u){iu.set(0,0,1),n.vmult(iu,iu);let c=0;for(let n=0;n!==e.vertices.length;n++){ih.copy(e.vertices[n]),o.vmult(ih,ih),s.vadd(ih,ih),ih.vsub(i,ic);let d=iu.dot(ic);if(d<=0){if(u)return!0;let n=this.createContactEquation(r,l,t,e,a,h);iu.scale(iu.dot(ic),id),ih.vsub(id,id),id.vsub(i,n.ri),n.ni.copy(iu),ih.vsub(s,n.rj),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),n.rj.vadd(s,n.rj),n.rj.vsub(l.position,n.rj),this.result.push(n),c++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(n,this.frictionResult)}}this.enableFrictionReduction&&c&&this.createFrictionFromAverage(c)}boxConvex(t,e,i,s,n,o,r,l,a,h,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(t.convexPolyhedronRepresentation,e,i,s,n,o,r,l,t,e,u)}sphereHeightfield(t,e,i,s,n,o,r,l,a,h,u){let c=e.data,d=t.radius,p=e.elementSize;S.pointToLocalFrame(s,o,i,iM);let y=Math.floor((iM.x-d)/p)-1,v=Math.ceil((iM.x+d)/p)+1,w=Math.floor((iM.y-d)/p)-1,m=Math.ceil((iM.y+d)/p)+1;if(v<0||m<0||y>c.length||w>c[0].length)return;y<0&&(y=0),v<0&&(v=0),w<0&&(w=0),m<0&&(m=0),y>=c.length&&(y=c.length-1),v>=c.length&&(v=c.length-1),m>=c[0].length&&(m=c[0].length-1),w>=c[0].length&&(w=c[0].length-1);let f=[];e.getRectMinMax(y,w,v,m,f);let g=f[0],x=f[1];if(iM.z-d>x||iM.z+d<g)return;let b=this.result;for(let a=y;a<v;a++)for(let h=w;h<m;h++){let c=b.length,d=!1;if(e.getConvexTrianglePillar(a,h,!1),S.pointToWorldFrame(s,o,e.pillarOffset,iF),i.distanceTo(iF)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(d=this.sphereConvex(t,e.pillarConvex,i,iF,n,o,r,l,t,e,u)),u&&d||(e.getConvexTrianglePillar(a,h,!0),S.pointToWorldFrame(s,o,e.pillarOffset,iF),i.distanceTo(iF)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(d=this.sphereConvex(t,e.pillarConvex,i,iF,n,o,r,l,t,e,u)),u&&d))return!0;let p=b.length-c;if(p>2)return}}boxHeightfield(t,e,i,s,n,o,r,l,a,h,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexHeightfield(t.convexPolyhedronRepresentation,e,i,s,n,o,r,l,t,e,u)}convexHeightfield(t,e,i,s,n,o,r,l,a,h,u){let c=e.data,d=e.elementSize,p=t.boundingSphereRadius;S.pointToLocalFrame(s,o,i,iS);let y=Math.floor((iS.x-p)/d)-1,v=Math.ceil((iS.x+p)/d)+1,w=Math.floor((iS.y-p)/d)-1,m=Math.ceil((iS.y+p)/d)+1;if(v<0||m<0||y>c.length||w>c[0].length)return;y<0&&(y=0),v<0&&(v=0),w<0&&(w=0),m<0&&(m=0),y>=c.length&&(y=c.length-1),v>=c.length&&(v=c.length-1),m>=c[0].length&&(m=c[0].length-1),w>=c[0].length&&(w=c[0].length-1);let f=[];e.getRectMinMax(y,w,v,m,f);let g=f[0],x=f[1];if(!(iS.z-p>x)&&!(iS.z+p<g))for(let a=y;a<v;a++)for(let h=w;h<m;h++){let c=!1;if(e.getConvexTrianglePillar(a,h,!1),S.pointToWorldFrame(s,o,e.pillarOffset,iA),i.distanceTo(iA)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(c=this.convexConvex(t,e.pillarConvex,i,iA,n,o,r,l,null,null,u,iC,null)),u&&c||(e.getConvexTrianglePillar(a,h,!0),S.pointToWorldFrame(s,o,e.pillarOffset,iA),i.distanceTo(iA)<e.pillarConvex.boundingSphereRadius+t.boundingSphereRadius&&(c=this.convexConvex(t,e.pillarConvex,i,iA,n,o,r,l,null,null,u,iC,null)),u&&c))return!0}}sphereParticle(t,e,i,s,n,o,r,l,a,h,u){ig.set(0,0,1),s.vsub(i,ig);let c=ig.lengthSquared();if(c<=t.radius*t.radius){if(u)return!0;let i=this.createContactEquation(l,r,e,t,a,h);ig.normalize(),i.rj.copy(ig),i.rj.scale(t.radius,i.rj),i.ni.copy(ig),i.ni.negate(i.ni),i.ri.set(0,0,0),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}planeParticle(t,e,i,s,n,o,r,l,a,h,u){iv.set(0,0,1),r.quaternion.vmult(iv,iv),s.vsub(r.position,iw);let c=iv.dot(iw);if(c<=0){if(u)return!0;let i=this.createContactEquation(l,r,e,t,a,h);i.ni.copy(iv),i.ni.negate(i.ni),i.ri.set(0,0,0),iv.scale(iv.dot(s),im),s.vsub(im,im),i.rj.copy(im),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}boxParticle(t,e,i,s,n,o,r,l,a,h,u){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexParticle(t.convexPolyhedronRepresentation,e,i,s,n,o,r,l,t,e,u)}convexParticle(t,e,i,s,n,o,r,l,a,h,u){let c=-1,d=null;if(ib.copy(s),ib.vsub(i,ib),n.conjugate(ix),ix.vmult(ib,ib),t.pointIsInside(ib)){t.worldVerticesNeedsUpdate&&t.computeWorldVertices(i,n),t.worldFaceNormalsNeedsUpdate&&t.computeWorldFaceNormals(n);for(let e=0,i=t.faces.length;e!==i;e++){let i=[t.worldVertices[t.faces[e][0]]],n=t.worldFaceNormals[e];s.vsub(i[0],iz);let o=-n.dot(iz);if(null===d||Math.abs(o)<Math.abs(d)){if(u)return!0;d=o,c=e,iE.copy(n)}}if(-1!==c){let n=this.createContactEquation(l,r,e,t,a,h);iE.scale(d,iB),iB.vadd(s,iB),iB.vsub(i,iB),n.rj.copy(iB),iE.negate(n.ni),n.ri.set(0,0,0);let o=n.ri,u=n.rj;o.vadd(s,o),o.vsub(l.position,o),u.vadd(i,u),u.vsub(r.position,u),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(t,e,i,s,n,o,r,l,a,h,u){return this.convexHeightfield(e,t,s,i,o,n,l,r,a,h,u)}particleCylinder(t,e,i,s,n,o,r,l,a,h,u){return this.convexParticle(e,t,s,i,o,n,l,r,a,h,u)}sphereTrimesh(t,e,i,s,n,o,r,l,a,h,u){let c=eY;S.pointToLocalFrame(s,o,i,eW);let d=t.radius;eU.lowerBound.set(eW.x-d,eW.y-d,eW.z-d),eU.upperBound.set(eW.x+d,eW.y+d,eW.z+d),e.getTrianglesInAABB(eU,c);let p=t.radius*t.radius;for(let n=0;n<c.length;n++)for(let d=0;d<3;d++)if(e.getVertex(e.indices[3*c[n]+d],eI),eI.vsub(eW,eP),eP.lengthSquared()<=p){if(eL.copy(eI),S.pointToWorldFrame(s,o,eL,eI),eI.vsub(i,eP),u)return!0;let n=this.createContactEquation(r,l,t,e,a,h);n.ni.copy(eP),n.ni.normalize(),n.ri.copy(n.ni),n.ri.scale(t.radius,n.ri),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),n.rj.copy(eI),n.rj.vsub(l.position,n.rj),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}for(let n=0;n<c.length;n++)for(let d=0;d<3;d++){e.getVertex(e.indices[3*c[n]+d],ej),e.getVertex(e.indices[3*c[n]+(d+1)%3],eV),eV.vsub(ej,eO),eW.vsub(eV,eH);let p=eH.dot(eO);eW.vsub(ej,eH);let y=eH.dot(eO);if(y>0&&p<0){eW.vsub(ej,eH),ek.copy(eO),ek.normalize(),y=eH.dot(ek),ek.scale(y,eH),eH.vadd(ej,eH);let n=eH.distanceTo(eW);if(n<t.radius){if(u)return!0;let n=this.createContactEquation(r,l,t,e,a,h);eH.vsub(eW,n.ni),n.ni.normalize(),n.ni.scale(t.radius,n.ri),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),S.pointToWorldFrame(s,o,eH,eH),eH.vsub(l.position,n.rj),S.vectorToWorldFrame(o,n.ni,n.ni),S.vectorToWorldFrame(o,n.ri,n.ri),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}}for(let n=0,d=c.length;n!==d;n++){e.getTriangleVertices(c[n],eD,e_,eG),e.getNormal(c[n],eR),eW.vsub(eD,eH);let d=eH.dot(eR);if(eR.scale(d,eH),eW.vsub(eH,eH),d=eH.distanceTo(eW),to.pointInTriangle(eH,eD,e_,eG)&&d<t.radius){if(u)return!0;let n=this.createContactEquation(r,l,t,e,a,h);eH.vsub(eW,n.ni),n.ni.normalize(),n.ni.scale(t.radius,n.ri),n.ri.vadd(i,n.ri),n.ri.vsub(r.position,n.ri),S.pointToWorldFrame(s,o,eH,eH),eH.vsub(l.position,n.rj),S.vectorToWorldFrame(o,n.ni,n.ni),S.vectorToWorldFrame(o,n.ri,n.ri),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult)}}c.length=0}planeTrimesh(t,e,i,s,n,o,r,l,a,h,u){let c=new d;eN.set(0,0,1),n.vmult(eN,eN);for(let n=0;n<e.vertices.length/3;n++){e.getVertex(n,c);let p=new d;p.copy(c),S.pointToWorldFrame(s,o,p,c),c.vsub(i,eq);let y=eN.dot(eq);if(y<=0){if(u)return!0;let i=this.createContactEquation(r,l,t,e,a,h);i.ni.copy(eN),eN.scale(eq.dot(eN),eT),c.vsub(eT,eT),i.ri.copy(eT),i.ri.vsub(r.position,i.ri),i.rj.copy(c),i.rj.vsub(l.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}}}let ez=new d,eB=new d,eS=new d,eA=new d,eC=new d,eM=new b,eF=new b,eN=new d,eq=new d,eT=new d,eR=new d,eP=new d;new d;let eI=new d,eL=new d,ej=new d,eV=new d,eO=new d,ek=new d,eW=new d,eH=new d,eD=new d,e_=new d,eG=new d,eU=new w,eY=[],eX=new d,e$=new d,eK=new d,eZ=new d,eQ=new d,eJ=new d,e0=new d,e1=new d,e2=new d,e3=[new d,new d,new d,new d,new d,new d],e6=new d,e4=new d,e5=new d,e7=new d,e8=new d,e9=new d,it=new d,ie=new d,ii=new d,is=new d,io=new d,ir=new d,il=new d,ia=new d;new d,new d;let ih=new d,iu=new d,ic=new d,id=new d,ip=new d,iy=new d,iv=new d,iw=new d,im=new d,ig=new d,ix=new b,ib=new d;new d;let iE=new d,iz=new d,iB=new d,iS=new d,iA=new d,iC=[0],iM=new d,iF=new d;class iN{constructor(){this.current=[],this.previous=[]}getKey(t,e){if(e<t){let i=e;e=t,t=i}return t<<16|e}set(t,e){let i=this.getKey(t,e),s=this.current,n=0;for(;i>s[n];)n++;if(i!==s[n]){for(let t=s.length-1;t>=n;t--)s[t+1]=s[t];s[n]=i}}tick(){let t=this.current;this.current=this.previous,this.previous=t,this.current.length=0}getDiff(t,e){let i=this.current,s=this.previous,n=i.length,o=s.length,r=0;for(let e=0;e<n;e++){let n=i[e];for(;n>s[r];)r++;n===s[r]||iq(t,n)}r=0;for(let t=0;t<o;t++){let n=s[t];for(;n>i[r];)r++;i[r]===n||iq(e,n)}}}function iq(t,e){t.push((4294901760&e)>>16,65535&e)}let iT=(t,e)=>t<e?`${t}-${e}`:`${e}-${t}`;class iR{constructor(){this.data={keys:[]}}get(t,e){let i=iT(t,e);return this.data[i]}set(t,e,i){let s=iT(t,e);this.get(t,e)||this.data.keys.push(s),this.data[s]=i}delete(t,e){let i=iT(t,e),s=this.data.keys.indexOf(i);-1!==s&&this.data.keys.splice(s,1),delete this.data[i]}reset(){let t=this.data,e=t.keys;for(;e.length>0;){let i=e.pop();delete t[i]}}}class iP extends x{constructor(t){void 0===t&&(t={}),super(),this.dt=-1,this.allowSleep=!!t.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=void 0!==t.quatNormalizeSkip?t.quatNormalizeSkip:0,this.quatNormalizeFast=void 0!==t.quatNormalizeFast&&t.quatNormalizeFast,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new d,t.gravity&&this.gravity.copy(t.gravity),t.frictionGravity&&(this.frictionGravity=new d,this.frictionGravity.copy(t.frictionGravity)),this.broadphase=void 0!==t.broadphase?t.broadphase:new ti,this.bodies=[],this.hasActiveBodies=!1,this.solver=void 0!==t.solver?t.solver:new ev,this.constraints=[],this.narrowphase=new eE(this),this.collisionMatrix=new g,this.collisionMatrixPrevious=new g,this.bodyOverlapKeeper=new iN,this.shapeOverlapKeeper=new iN,this.contactmaterials=[],this.contactMaterialTable=new iR,this.defaultMaterial=new t3("default"),this.defaultContactMaterial=new t2(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(t,e){return this.contactMaterialTable.get(t.id,e.id)}collisionMatrixTick(){let t=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=t,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(t){this.constraints.push(t)}removeConstraint(t){let e=this.constraints.indexOf(t);-1!==e&&this.constraints.splice(e,1)}rayTest(t,e,i){i instanceof ts?this.raycastClosest(t,e,{skipBackfaces:!0},i):this.raycastAll(t,e,{skipBackfaces:!0},i)}raycastAll(t,e,i,s){return void 0===i&&(i={}),i.mode=to.ALL,i.from=t,i.to=e,i.callback=s,iI.intersectWorld(this,i)}raycastAny(t,e,i,s){return void 0===i&&(i={}),i.mode=to.ANY,i.from=t,i.to=e,i.result=s,iI.intersectWorld(this,i)}raycastClosest(t,e,i,s){return void 0===i&&(i={}),i.mode=to.CLOSEST,i.from=t,i.to=e,i.result=s,iI.intersectWorld(this,i)}addBody(t){this.bodies.includes(t)||(t.index=this.bodies.length,this.bodies.push(t),t.world=this,t.initPosition.copy(t.position),t.initVelocity.copy(t.velocity),t.timeLastSleepy=this.time,t instanceof j&&(t.initAngularVelocity.copy(t.angularVelocity),t.initQuaternion.copy(t.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=t,this.idToBodyMap[t.id]=t,this.dispatchEvent(this.addBodyEvent))}removeBody(t){t.world=null;let e=this.bodies.length-1,i=this.bodies,s=i.indexOf(t);if(-1!==s){i.splice(s,1);for(let t=0;t!==i.length;t++)i[t].index=t;this.collisionMatrix.setNumObjects(e),this.removeBodyEvent.body=t,delete this.idToBodyMap[t.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(t){return this.idToBodyMap[t]}getShapeById(t){let e=this.bodies;for(let i=0;i<e.length;i++){let s=e[i].shapes;for(let e=0;e<s.length;e++){let i=s[e];if(i.id===t)return i}}return null}addContactMaterial(t){this.contactmaterials.push(t),this.contactMaterialTable.set(t.materials[0].id,t.materials[1].id,t)}removeContactMaterial(t){let e=this.contactmaterials.indexOf(t);-1!==e&&(this.contactmaterials.splice(e,1),this.contactMaterialTable.delete(t.materials[0].id,t.materials[1].id))}fixedStep(t,e){void 0===t&&(t=1/60),void 0===e&&(e=10);let i=iL.now()/1e3;if(this.lastCallTime){let s=i-this.lastCallTime;this.step(t,s,e)}else this.step(t,void 0,e);this.lastCallTime=i}step(t,e,i){if(void 0===i&&(i=10),void 0===e)this.internalStep(t),this.time+=t;else{this.accumulator+=e;let s=iL.now(),n=0;for(;this.accumulator>=t&&n<i&&(this.internalStep(t),this.accumulator-=t,n++,!(iL.now()-s>1e3*t)););this.accumulator=this.accumulator%t;let o=this.accumulator/t;for(let t=0;t!==this.bodies.length;t++){let e=this.bodies[t];e.previousPosition.lerp(e.position,o,e.interpolatedPosition),e.previousQuaternion.slerp(e.quaternion,o,e.interpolatedQuaternion),e.previousQuaternion.normalize()}this.time+=e}}internalStep(t){this.dt=t;let e=this.contacts,i=iH,s=iD,n=this.bodies.length,o=this.bodies,r=this.solver,l=this.gravity,a=this.doProfiling,h=this.profile,u=j.DYNAMIC,c=-1/0,d=this.constraints;l.length();let p=l.x,y=l.y,v=l.z,w=0;for(a&&(c=iL.now()),w=0;w!==n;w++){let t=o[w];if(t.type===u){let e=t.force,i=t.mass;e.x+=i*p,e.y+=i*y,e.z+=i*v}}for(let t=0,e=this.subsystems.length;t!==e;t++)this.subsystems[t].update();a&&(c=iL.now()),i.length=0,s.length=0,this.broadphase.collisionPairs(this,i,s),a&&(h.broadphase=iL.now()-c);let m=d.length;for(w=0;w!==m;w++){let t=d[w];if(!t.collideConnected)for(let e=i.length-1;e>=0;e-=1)(t.bodyA===i[e]&&t.bodyB===s[e]||t.bodyB===i[e]&&t.bodyA===s[e])&&(i.splice(e,1),s.splice(e,1))}this.collisionMatrixTick(),a&&(c=iL.now());let f=e.length;for(w=0;w!==f;w++)ik.push(e[w]);e.length=0;let g=this.frictionEquations.length;for(w=0;w!==g;w++)iW.push(this.frictionEquations[w]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(i,s,this,e,ik,this.frictionEquations,iW),a&&(h.narrowphase=iL.now()-c),a&&(c=iL.now()),w=0;w<this.frictionEquations.length;w++)r.addEquation(this.frictionEquations[w]);let x=e.length;for(let t=0;t!==x;t++){let i=e[t],s=i.bi,n=i.bj,o=i.si,l=i.sj;if((s.material&&n.material&&this.getContactMaterial(s.material,n.material)||this.defaultContactMaterial).friction,s.material&&n.material&&(s.material.friction>=0&&n.material.friction>=0&&(s.material.friction,n.material.friction),s.material.restitution>=0&&n.material.restitution>=0&&(i.restitution=s.material.restitution*n.material.restitution)),r.addEquation(i),s.allowSleep&&s.type===j.DYNAMIC&&s.sleepState===j.SLEEPING&&n.sleepState===j.AWAKE&&n.type!==j.STATIC){let t=n.velocity.lengthSquared()+n.angularVelocity.lengthSquared(),e=n.sleepSpeedLimit**2;t>=2*e&&(s.wakeUpAfterNarrowphase=!0)}if(n.allowSleep&&n.type===j.DYNAMIC&&n.sleepState===j.SLEEPING&&s.sleepState===j.AWAKE&&s.type!==j.STATIC){let t=s.velocity.lengthSquared()+s.angularVelocity.lengthSquared(),e=s.sleepSpeedLimit**2;t>=2*e&&(n.wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(s,n,!0),this.collisionMatrixPrevious.get(s,n)||(iO.body=n,iO.contact=i,s.dispatchEvent(iO),iO.body=s,n.dispatchEvent(iO)),this.bodyOverlapKeeper.set(s.id,n.id),this.shapeOverlapKeeper.set(o.id,l.id)}for(this.emitContactEvents(),a&&(h.makeContactConstraints=iL.now()-c,c=iL.now()),w=0;w!==n;w++){let t=o[w];t.wakeUpAfterNarrowphase&&(t.wakeUp(),t.wakeUpAfterNarrowphase=!1)}for(w=0,m=d.length;w!==m;w++){let t=d[w];t.update();for(let e=0,i=t.equations.length;e!==i;e++){let i=t.equations[e];r.addEquation(i)}}r.solve(t,this),a&&(h.solve=iL.now()-c),r.removeAllEquations();let b=Math.pow;for(w=0;w!==n;w++){let e=o[w];if(e.type&u){let i=b(1-e.linearDamping,t),s=e.velocity;s.scale(i,s);let n=e.angularVelocity;if(n){let i=b(1-e.angularDamping,t);n.scale(i,n)}}}this.dispatchEvent(iV),a&&(c=iL.now());let E=this.stepnumber,z=E%(this.quatNormalizeSkip+1)==0,B=this.quatNormalizeFast;for(w=0;w!==n;w++)o[w].integrate(t,z,B);this.clearForces(),this.broadphase.dirty=!0,a&&(h.integrate=iL.now()-c),this.stepnumber+=1,this.dispatchEvent(ij);let S=!0;if(this.allowSleep)for(w=0,S=!1;w!==n;w++){let t=o[w];t.sleepTick(this.time),t.sleepState!==j.SLEEPING&&(S=!0)}this.hasActiveBodies=S}emitContactEvents(){let t=this.hasAnyEventListener("beginContact"),e=this.hasAnyEventListener("endContact");if((t||e)&&this.bodyOverlapKeeper.getDiff(i_,iG),t){for(let t=0,e=i_.length;t<e;t+=2)iU.bodyA=this.getBodyById(i_[t]),iU.bodyB=this.getBodyById(i_[t+1]),this.dispatchEvent(iU);iU.bodyA=iU.bodyB=null}if(e){for(let t=0,e=iG.length;t<e;t+=2)iY.bodyA=this.getBodyById(iG[t]),iY.bodyB=this.getBodyById(iG[t+1]),this.dispatchEvent(iY);iY.bodyA=iY.bodyB=null}i_.length=iG.length=0;let i=this.hasAnyEventListener("beginShapeContact"),s=this.hasAnyEventListener("endShapeContact");if((i||s)&&this.shapeOverlapKeeper.getDiff(i_,iG),i){for(let t=0,e=i_.length;t<e;t+=2){let e=this.getShapeById(i_[t]),i=this.getShapeById(i_[t+1]);iX.shapeA=e,iX.shapeB=i,e&&(iX.bodyA=e.body),i&&(iX.bodyB=i.body),this.dispatchEvent(iX)}iX.bodyA=iX.bodyB=iX.shapeA=iX.shapeB=null}if(s){for(let t=0,e=iG.length;t<e;t+=2){let e=this.getShapeById(iG[t]),i=this.getShapeById(iG[t+1]);i$.shapeA=e,i$.shapeB=i,e&&(i$.bodyA=e.body),i&&(i$.bodyB=i.body),this.dispatchEvent(i$)}i$.bodyA=i$.bodyB=i$.shapeA=i$.shapeB=null}}clearForces(){let t=this.bodies,e=t.length;for(let i=0;i!==e;i++){let e=t[i];e.force,e.torque,e.force.set(0,0,0),e.torque.set(0,0,0)}}}new w;let iI=new to,iL=globalThis.performance||{};if(!iL.now){let t=Date.now();iL.timing&&iL.timing.navigationStart&&(t=iL.timing.navigationStart),iL.now=()=>Date.now()-t}new d;let ij={type:"postStep"},iV={type:"preStep"},iO={type:j.COLLIDE_EVENT_NAME,body:null,contact:null},ik=[],iW=[],iH=[],iD=[],i_=[],iG=[],iU={type:"beginContact",bodyA:null,bodyB:null},iY={type:"endContact",bodyA:null,bodyB:null},iX={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},i$={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null}}}]);