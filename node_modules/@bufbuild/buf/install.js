"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// <define:ALL_BINS>
var define_ALL_BINS_default = { buf: "./bin/buf", "protoc-gen-buf-breaking": "./bin/protoc-gen-buf-breaking", "protoc-gen-buf-lint": "./bin/protoc-gen-buf-lint" };

// scripts/platform.ts
var os = __toESM(require("os"));
var knownWindowsPackages = {
  "win32 arm64 LE": "@bufbuild/buf-win32-arm64",
  "win32 x64 LE": "@bufbuild/buf-win32-x64"
};
var knownUnixlikePackages = {
  "darwin arm64 LE": "@bufbuild/buf-darwin-arm64",
  "darwin x64 LE": "@bufbuild/buf-darwin-x64",
  "linux arm64 LE": "@bufbuild/buf-linux-aarch64",
  "linux x64 LE": "@bufbuild/buf-linux-x64"
};
function pkgAndSubpathForCurrentPlatform(binKey = "buf") {
  let pkg;
  let subpath;
  let platformKey = `${process.platform} ${os.arch()} ${os.endianness()}`;
  if (platformKey in knownWindowsPackages) {
    pkg = knownWindowsPackages[platformKey];
    subpath = `bin/${binKey}.exe`;
  } else if (platformKey in knownUnixlikePackages) {
    pkg = knownUnixlikePackages[platformKey];
    subpath = `bin/${binKey}`;
  } else {
    throw new Error(`Unsupported platform: ${platformKey}`);
  }
  return { pkg, subpath };
}

// scripts/install.ts
var child_process = __toESM(require("child_process"));
var path = __toESM(require("path"));
var fs = __toESM(require("fs"));
function downloadedBinPath(pkg, subpath) {
  const rootLibDir = path.dirname(require.resolve("@bufbuild/buf"));
  return path.join(rootLibDir, `downloaded-${pkg.replace("/", "-")}-${path.basename(subpath)}`);
}
function validateBinaryVersion(...command) {
  command.push("--version");
  const stdout = child_process.execFileSync(command.shift(), command, {
    // Without this, this install script strangely crashes with the error
    // "EACCES: permission denied, write" but only on Ubuntu Linux when node is
    // installed from the Snap Store. This is not a problem when you download
    // the official version of node. The problem appears to be that stderr
    // (i.e. file descriptor 2) isn't writable?
    //
    // More info:
    // - https://snapcraft.io/ (what the Snap Store is)
    // - https://nodejs.org/dist/ (download the official version of node)
    // - https://github.com/evanw/esbuild/issues/1711#issuecomment-1027554035
    //
    stdio: "pipe"
  }).toString().trim();
  const currentVersionWithoutRevision = "1.15.0".split("-")[0];
  if (stdout !== currentVersionWithoutRevision) {
    throw new Error(
      `Expected ${JSON.stringify(currentVersionWithoutRevision)} but got ${JSON.stringify(
        stdout
      )}`
    );
  }
}
async function checkAndPreparePackage(binKey) {
  const { pkg, subpath } = pkgAndSubpathForCurrentPlatform(binKey);
  let binPath;
  try {
    binPath = require.resolve(`${pkg}/${subpath}`);
  } catch (e) {
    console.warn(`[buf] Failed to find package "${pkg}" on the file system

This can happen if you use the "--no-optional" flag. The "optionalDependencies"
package.json feature is used by buf to install the correct binary executable
for your current platform. Going to try installing from npm directly.
`);
    binPath = downloadedBinPath(pkg, subpath);
    console.error(`[buf] Trying to install package "${pkg}" using npm`);
    installUsingNPM(pkg, subpath, binPath);
  }
  return {
    toPath: binPath
  };
}
async function checkAllBinaries() {
  for (const [binKey] of Object.entries(define_ALL_BINS_default)) {
    const { toPath } = await checkAndPreparePackage(binKey);
    if (binKey === "buf") {
      validateBinaryVersion(toPath);
    }
  }
}
function installUsingNPM(pkg, subpath, binPath) {
  const env = { ...process.env, npm_config_global: void 0 };
  const libDir = path.dirname(require.resolve("@bufbuild/buf"));
  const installDir = path.join(libDir, "npm-install");
  fs.mkdirSync(installDir);
  try {
    fs.writeFileSync(path.join(installDir, "package.json"), "{}");
    child_process.execSync(
      `npm install --loglevel=error --prefer-offline --no-audit --progress=false ${pkg}@${"1.15.0"}`,
      { cwd: installDir, stdio: "pipe", env }
    );
    const installedBinPath = path.join(
      installDir,
      "node_modules",
      pkg,
      subpath
    );
    fs.renameSync(installedBinPath, binPath);
  } finally {
    try {
      removeRecursive(installDir);
    } catch {
    }
  }
}
function removeRecursive(dir) {
  for (const entry of fs.readdirSync(dir)) {
    const entryPath = path.join(dir, entry);
    let stats;
    try {
      stats = fs.lstatSync(entryPath);
    } catch {
      continue;
    }
    if (stats.isDirectory())
      removeRecursive(entryPath);
    else
      fs.unlinkSync(entryPath);
  }
  fs.rmdirSync(dir);
}
checkAllBinaries();
