// Copyright 2021-2023 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { BinaryReader, BinaryWriter, WireType, } from "../binary-encoding.js";
import { Message } from "../message.js";
import { ScalarType } from "../field.js";
import { wrapField } from "./field-wrapper.js";
import { scalarDefaultValue, scalarTypeInfo } from "./scalars.js";
import { assert } from "./assert.js";
/* eslint-disable @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call, @typescript-eslint/no-unnecessary-condition, no-case-declarations, prefer-const */
const unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields");
// Default options for parsing binary data.
const readDefaults = {
    readUnknownFields: true,
    readerFactory: (bytes) => new BinaryReader(bytes),
};
// Default options for serializing binary data.
const writeDefaults = {
    writeUnknownFields: true,
    writerFactory: () => new BinaryWriter(),
};
function makeReadOptions(options) {
    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
}
function makeWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
}
export function makeBinaryFormatCommon() {
    return {
        makeReadOptions,
        makeWriteOptions,
        listUnknownFields(message) {
            var _a;
            return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];
        },
        discardUnknownFields(message) {
            delete message[unknownFieldsSymbol];
        },
        writeUnknownFields(message, writer) {
            const m = message;
            const c = m[unknownFieldsSymbol];
            if (c) {
                for (const f of c) {
                    writer.tag(f.no, f.wireType).raw(f.data);
                }
            }
        },
        onUnknownField(message, no, wireType, data) {
            const m = message;
            if (!Array.isArray(m[unknownFieldsSymbol])) {
                m[unknownFieldsSymbol] = [];
            }
            m[unknownFieldsSymbol].push({ no, wireType, data });
        },
        readMessage(message, reader, length, options) {
            const type = message.getType();
            const end = length === undefined ? reader.len : reader.pos + length;
            while (reader.pos < end) {
                const [fieldNo, wireType] = reader.tag(), field = type.fields.find(fieldNo);
                if (!field) {
                    const data = reader.skip(wireType);
                    if (options.readUnknownFields) {
                        this.onUnknownField(message, fieldNo, wireType, data);
                    }
                    continue;
                }
                let target = message, repeated = field.repeated, localName = field.localName;
                if (field.oneof) {
                    target = target[field.oneof.localName];
                    if (target.case != localName) {
                        delete target.value;
                    }
                    target.case = localName;
                    localName = "value";
                }
                switch (field.kind) {
                    case "scalar":
                    case "enum":
                        const scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
                        if (repeated) {
                            let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values
                            if (wireType == WireType.LengthDelimited &&
                                scalarType != ScalarType.STRING &&
                                scalarType != ScalarType.BYTES) {
                                let e = reader.uint32() + reader.pos;
                                while (reader.pos < e) {
                                    arr.push(readScalar(reader, scalarType));
                                }
                            }
                            else {
                                arr.push(readScalar(reader, scalarType));
                            }
                        }
                        else {
                            target[localName] = readScalar(reader, scalarType);
                        }
                        break;
                    case "message":
                        const messageType = field.T;
                        if (repeated) {
                            // safe to assume presence of array, oneof cannot contain repeated values
                            target[localName].push(messageType.fromBinary(reader.bytes(), options));
                        }
                        else {
                            if (target[localName] instanceof Message) {
                                target[localName].fromBinary(reader.bytes(), options);
                            }
                            else {
                                target[localName] = messageType.fromBinary(reader.bytes(), options);
                                if (messageType.fieldWrapper &&
                                    !field.oneof &&
                                    !field.repeated) {
                                    target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);
                                }
                            }
                        }
                        break;
                    case "map":
                        let [mapKey, mapVal] = readMapEntry(field, reader, options);
                        // safe to assume presence of map object, oneof cannot contain repeated values
                        target[localName][mapKey] = mapVal;
                        break;
                }
            }
        },
    };
}
// Read a map field, expecting key field = 1, value field = 2
function readMapEntry(field, reader, options) {
    const length = reader.uint32(), end = reader.pos + length;
    let key, val;
    while (reader.pos < end) {
        let [fieldNo] = reader.tag();
        switch (fieldNo) {
            case 1:
                key = readScalar(reader, field.K);
                break;
            case 2:
                switch (field.V.kind) {
                    case "scalar":
                        val = readScalar(reader, field.V.T);
                        break;
                    case "enum":
                        val = reader.int32();
                        break;
                    case "message":
                        val = field.V.T.fromBinary(reader.bytes(), options);
                        break;
                }
                break;
        }
    }
    if (key === undefined) {
        let keyRaw = scalarDefaultValue(field.K);
        key =
            field.K == ScalarType.BOOL
                ? keyRaw.toString()
                : keyRaw;
    }
    if (typeof key != "string" && typeof key != "number") {
        key = key.toString();
    }
    if (val === undefined) {
        switch (field.V.kind) {
            case "scalar":
                val = scalarDefaultValue(field.V.T);
                break;
            case "enum":
                val = 0;
                break;
            case "message":
                val = new field.V.T();
                break;
        }
    }
    return [key, val];
}
function readScalar(reader, type) {
    let [, method] = scalarTypeInfo(type);
    return reader[method]();
}
export function writeMapEntry(writer, options, field, key, value) {
    writer.tag(field.no, WireType.LengthDelimited);
    writer.fork();
    // javascript only allows number or string for object properties
    // we convert from our representation to the protobuf type
    let keyValue = key;
    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- we deliberately handle just the special cases for map keys
    switch (field.K) {
        case ScalarType.INT32:
        case ScalarType.FIXED32:
        case ScalarType.UINT32:
        case ScalarType.SFIXED32:
        case ScalarType.SINT32:
            keyValue = Number.parseInt(key);
            break;
        case ScalarType.BOOL:
            assert(key == "true" || key == "false");
            keyValue = key == "true";
            break;
    }
    // write key, expecting key field number = 1
    writeScalar(writer, field.K, 1, keyValue, true);
    // write value, expecting value field number = 2
    switch (field.V.kind) {
        case "scalar":
            writeScalar(writer, field.V.T, 2, value, true);
            break;
        case "enum":
            writeScalar(writer, ScalarType.INT32, 2, value, true);
            break;
        case "message":
            writeMessageField(writer, options, field.V.T, 2, value);
            break;
    }
    writer.join();
}
export function writeMessageField(writer, options, type, fieldNo, value) {
    if (value !== undefined) {
        const message = wrapField(type, value);
        writer
            .tag(fieldNo, WireType.LengthDelimited)
            .bytes(message.toBinary(options));
    }
}
export function writeScalar(writer, type, fieldNo, value, emitIntrinsicDefault) {
    let [wireType, method, isIntrinsicDefault] = scalarTypeInfo(type, value);
    if (!isIntrinsicDefault || emitIntrinsicDefault) {
        writer.tag(fieldNo, wireType)[method](value);
    }
}
export function writePacked(writer, type, fieldNo, value) {
    if (!value.length) {
        return;
    }
    writer.tag(fieldNo, WireType.LengthDelimited).fork();
    let [, method] = scalarTypeInfo(type);
    for (let i = 0; i < value.length; i++) {
        writer[method](value[i]);
    }
    writer.join();
}
