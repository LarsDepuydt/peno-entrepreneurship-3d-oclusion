"use strict";
// Copyright 2021-2023 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGeneratedFile = void 0;
const import_symbol_js_1 = require("./import-symbol.js");
const gencommon_js_1 = require("./gencommon.js");
const import_path_js_1 = require("./import-path.js");
function createGeneratedFile(name, importPath, rewriteImportPath, createTypeImport, runtimeImports, preambleSettings, keepEmpty) {
    let preamble;
    const el = [];
    return {
        preamble(file) {
            preamble = (0, gencommon_js_1.makeFilePreamble)(file, preambleSettings.pluginName, preambleSettings.pluginVersion, preambleSettings.pluginParameter, preambleSettings.tsNocheck);
        },
        print(printableOrFragments, ...rest) {
            let printables;
            if (printableOrFragments != null &&
                Object.prototype.hasOwnProperty.call(printableOrFragments, "raw")) {
                // If called with a tagged template literal
                printables = buildPrintablesFromFragments(printableOrFragments, rest);
            }
            else {
                // If called with just an array of Printables
                printables =
                    printableOrFragments != null
                        ? [printableOrFragments, ...rest]
                        : rest;
            }
            printableToEl(printables, el, createTypeImport, runtimeImports);
            el.push("\n");
        },
        export(name) {
            return (0, import_symbol_js_1.createImportSymbol)(name, importPath);
        },
        import(typeOrName, from) {
            if (typeof typeOrName == "string") {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return (0, import_symbol_js_1.createImportSymbol)(typeOrName, from);
            }
            return createTypeImport(typeOrName);
        },
        getFileInfo() {
            const content = elToContent(el, importPath, rewriteImportPath);
            if (!keepEmpty && content.length === 0) {
                return;
            }
            return {
                name,
                content,
                preamble,
            };
        },
    };
}
exports.createGeneratedFile = createGeneratedFile;
function elToContent(el, importerPath, rewriteImportPath) {
    const c = [];
    const symbolToIdentifier = processImports(el, importerPath, rewriteImportPath, (typeOnly, from, names) => {
        const p = names.map(({ name, alias }) => alias == undefined ? name : `${name} as ${alias}`);
        const what = `{ ${p.join(", ")} }`;
        if (typeOnly) {
            c.push(`import type ${what} from ${(0, gencommon_js_1.literalString)(from)};\n`);
        }
        else {
            c.push(`import ${what} from ${(0, gencommon_js_1.literalString)(from)};\n`);
        }
    });
    if (c.length > 0) {
        c.push("\n");
    }
    for (const e of el) {
        if (typeof e == "string") {
            c.push(e);
            continue;
        }
        const ident = symbolToIdentifier.get(e.id);
        if (ident != undefined) {
            c.push(ident);
        }
    }
    return c.join("");
}
function printableToEl(printables, el, createTypeImport, runtimeImports) {
    for (const p of printables) {
        if (Array.isArray(p)) {
            printableToEl(p, el, createTypeImport, runtimeImports);
        }
        else {
            switch (typeof p) {
                case "string":
                    el.push(p);
                    break;
                case "number":
                    el.push(literalNumber(p));
                    break;
                case "boolean":
                    el.push(p.toString());
                    break;
                case "bigint":
                    el.push(...literalBigint(p, runtimeImports));
                    break;
                case "object":
                    if (p instanceof Uint8Array) {
                        el.push(literalUint8Array(p));
                        break;
                    }
                    switch (p.kind) {
                        case "es_symbol":
                            el.push(p);
                            break;
                        case "message":
                        case "enum":
                            el.push(createTypeImport(p));
                            break;
                    }
                    break;
                default:
                    throw `cannot print ${typeof p}`;
            }
        }
    }
}
function buildPrintablesFromFragments(fragments, values) {
    const printables = [];
    fragments.forEach((fragment, i) => {
        printables.push(fragment);
        if (fragments.length - 1 !== i) {
            printables.push(values[i]);
        }
    });
    return printables;
}
function processImports(el, importerPath, rewriteImportPath, makeImportStatement) {
    // identifiers to use in the output
    const symbolToIdentifier = new Map();
    // symbols that need a value import (as opposed to a type-only import)
    const symbolToIsValue = new Map();
    // taken in this file
    const identifiersTaken = new Set();
    // foreign symbols need an import
    const foreignSymbols = [];
    // Walk through all symbols used and populate the collections above.
    for (const s of el) {
        if (typeof s == "string") {
            continue;
        }
        symbolToIdentifier.set(s.id, s.name);
        if (!s.typeOnly) {
            // a symbol is only type-imported as long as all uses are type-only
            symbolToIsValue.set(s.id, true);
        }
        if (s.from === importerPath) {
            identifiersTaken.add(s.name);
        }
        else {
            foreignSymbols.push(s);
        }
    }
    // Walk through all foreign symbols and make their identifiers unique.
    const handledSymbols = new Set();
    for (const s of foreignSymbols) {
        if (handledSymbols.has(s.id)) {
            continue;
        }
        handledSymbols.add(s.id);
        if (!identifiersTaken.has(s.name)) {
            identifiersTaken.add(s.name);
            continue;
        }
        let i = 1;
        let alias;
        for (;;) {
            // We choose '$' because it is invalid in proto identifiers.
            alias = `${s.name}$${i}`;
            if (!identifiersTaken.has(alias)) {
                break;
            }
            i++;
        }
        identifiersTaken.add(alias);
        symbolToIdentifier.set(s.id, alias);
    }
    const sourceToImport = new Map();
    for (const s of foreignSymbols) {
        let i = sourceToImport.get(s.from);
        if (i == undefined) {
            i = {
                types: new Map(),
                values: new Map(),
            };
            sourceToImport.set(s.from, i);
        }
        let alias = symbolToIdentifier.get(s.id);
        if (alias == s.name) {
            alias = undefined;
        }
        if (symbolToIsValue.get(s.id)) {
            i.values.set(s.name, alias);
        }
        else {
            i.types.set(s.name, alias);
        }
    }
    // Make import statements.
    const handledSource = new Set();
    const buildNames = (map) => {
        const names = [];
        map.forEach((value, key) => names.push({ name: key, alias: value }));
        names.sort((a, b) => a.name.localeCompare(b.name));
        return names;
    };
    for (const s of foreignSymbols) {
        if (handledSource.has(s.from)) {
            continue;
        }
        handledSource.add(s.from);
        const i = sourceToImport.get(s.from);
        if (i == undefined) {
            // should never happen
            continue;
        }
        const from = (0, import_path_js_1.makeImportPathRelative)(importerPath, rewriteImportPath(s.from));
        if (i.types.size > 0) {
            makeImportStatement(true, from, buildNames(i.types));
        }
        if (i.values.size > 0) {
            makeImportStatement(false, from, buildNames(i.values));
        }
    }
    return symbolToIdentifier;
}
function literalNumber(value) {
    if (Number.isNaN(value)) {
        return "globalThis.Number.NaN";
    }
    if (value === Number.POSITIVE_INFINITY) {
        return "globalThis.Number.POSITIVE_INFINITY";
    }
    if (value === Number.NEGATIVE_INFINITY) {
        return "globalThis.Number.NEGATIVE_INFINITY";
    }
    return value.toString(10);
}
function literalBigint(value, runtimeImports) {
    // Loose comparison will match between 0n and 0.
    if (value == 0) {
        return [runtimeImports.protoInt64, ".zero"];
    }
    return [
        runtimeImports.protoInt64,
        ".parse(",
        (0, gencommon_js_1.literalString)(value.toString()),
        ")",
    ];
}
function literalUint8Array(value) {
    if (value.length === 0) {
        return "new Uint8Array(0)";
    }
    const strings = [];
    for (const n of value) {
        strings.push("0x" + n.toString(16).toUpperCase().padStart(2, "0"));
    }
    return `new Uint8Array([${strings.join(", ")}])`;
}
