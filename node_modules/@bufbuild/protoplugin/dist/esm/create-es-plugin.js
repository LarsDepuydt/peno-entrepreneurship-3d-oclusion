// Copyright 2021-2023 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { createSchema, toResponse } from "./ecmascript/schema.js";
import { transpile } from "./ecmascript/transpile.js";
import { PluginOptionError } from "./error.js";
/**
 * Create a new code generator plugin for ECMAScript.
 * The plugin can generate JavaScript, TypeScript, or TypeScript declaration
 * files.
 */
export function createEcmaScriptPlugin(init) {
    let transpileJs = false;
    let transpileDts = false;
    return {
        name: init.name,
        version: init.version,
        run(req) {
            var _a;
            const { targets, tsNocheck, bootstrapWkt, rewriteImports, importExtension, keepEmptyFiles, pluginParameter, } = parseParameter(req.parameter, init.parseOption);
            const { schema, getFileInfo } = createSchema(req, targets, tsNocheck, bootstrapWkt, rewriteImports, importExtension, keepEmptyFiles, init.name, init.version, pluginParameter);
            const targetTs = schema.targets.includes("ts");
            const targetJs = schema.targets.includes("js");
            const targetDts = schema.targets.includes("dts");
            // Generate TS files under the following conditions:
            // - if they are explicitly specified as a target.
            // - if js is specified as a target but no js generator is provided.
            // - if dts is specified as a target, but no dts generator is provided.
            // In the latter two cases, it is because we need the generated TS files
            // to use for transpiling js and/or dts.
            let tsFiles = [];
            if (targetTs ||
                (targetJs && !init.generateJs) ||
                (targetDts && !init.generateDts)) {
                init.generateTs(schema, "ts");
                // Save off the generated TypeScript files so that we can pass these
                // to the transpilation process if necessary.  We do not want to pass
                // JavaScript files for a few reasons:
                // 1.  Our usage of allowJs in the compiler options will cause issues
                // with attempting to transpile .ts and .js files to the same location.
                // 2.  There should be no reason to transpile JS because generateTs
                // functions are required, so users would never be able to only specify
                // a generateJs function and expect to transpile declarations.
                // 3.  Transpiling is somewhat expensive and situations with an
                // extremely large amount of files could have performance impacts.
                tsFiles = getFileInfo();
            }
            if (targetJs) {
                if (init.generateJs) {
                    init.generateJs(schema, "js");
                }
                else {
                    transpileJs = true;
                }
            }
            if (targetDts) {
                if (init.generateDts) {
                    init.generateDts(schema, "dts");
                }
                else {
                    transpileDts = true;
                }
            }
            // Get generated files.  If ts was specified as a target, then we want
            // all generated files.  If ts was not specified, we still may have
            // generated TypeScript files to assist in transpilation.  If they were
            // generated but not specified in the target out, we shouldn't produce
            // these files in the CodeGeneratorResponse.
            let files = getFileInfo();
            if (!targetTs && tsFiles.length > 0) {
                files = files.filter((file) => !tsFiles.some((tsFile) => tsFile.name === file.name));
            }
            // If either boolean is true, it means it was specified in the target out
            // but no generate function was provided.  This also means that we will
            // have generated .ts files above.
            if (transpileJs || transpileDts) {
                const transpileFn = (_a = init.transpile) !== null && _a !== void 0 ? _a : transpile;
                // Transpile the TypeScript files and add to the master list of files
                const transpiledFiles = transpileFn(tsFiles, transpileJs, transpileDts);
                files.push(...transpiledFiles);
            }
            return toResponse(files);
        },
    };
}
function parseParameter(parameter, parseOption) {
    let targets = ["js", "dts"];
    let tsNocheck = true;
    let bootstrapWkt = false;
    let keepEmptyFiles = false;
    const rewriteImports = [];
    let importExtension = ".js";
    const rawParameters = [];
    for (const { key, value, raw } of splitParameter(parameter)) {
        // Whether this key/value plugin parameter pair should be
        // printed to the generated file preamble
        let printToFile = true;
        switch (key) {
            case "target":
                targets = [];
                for (const rawTarget of value.split("+")) {
                    switch (rawTarget) {
                        case "js":
                        case "ts":
                        case "dts":
                            if (targets.indexOf(rawTarget) < 0) {
                                targets.push(rawTarget);
                            }
                            break;
                        default:
                            throw new PluginOptionError(`${key}=${value}`);
                    }
                }
                value.split("+");
                break;
            case "ts_nocheck":
                switch (value) {
                    case "true":
                    case "1":
                        tsNocheck = true;
                        break;
                    case "false":
                    case "0":
                        tsNocheck = false;
                        break;
                    default:
                        throw new PluginOptionError(`${key}=${value}`);
                }
                break;
            case "bootstrap_wkt":
                switch (value) {
                    case "true":
                    case "1":
                        bootstrapWkt = true;
                        break;
                    case "false":
                    case "0":
                        bootstrapWkt = false;
                        break;
                    default:
                        throw new PluginOptionError(`${key}=${value}`);
                }
                break;
            case "rewrite_imports": {
                const parts = value.split(":");
                if (parts.length !== 2) {
                    throw new PluginOptionError(`${key}=${value}`, "must be in the form of <pattern>:<target>");
                }
                const [pattern, target] = parts;
                rewriteImports.push({ pattern, target });
                // rewrite_imports can be noisy and is more of an implementation detail
                // so we strip it out of the preamble
                printToFile = false;
                break;
            }
            case "import_extension": {
                importExtension = value === "none" ? "" : value;
                break;
            }
            case "keep_empty_files": {
                switch (value) {
                    case "true":
                    case "1":
                        keepEmptyFiles = true;
                        break;
                    case "false":
                    case "0":
                        keepEmptyFiles = false;
                        break;
                    default:
                        throw new PluginOptionError(`${key}=${value}`);
                }
                break;
            }
            default:
                if (parseOption === undefined) {
                    throw new PluginOptionError(`${key}=${value}`);
                }
                try {
                    parseOption(key, value);
                }
                catch (e) {
                    throw new PluginOptionError(`${key}=${value}`, e);
                }
                break;
        }
        if (printToFile) {
            rawParameters.push(raw);
        }
    }
    const pluginParameter = rawParameters.join(",");
    return {
        targets,
        tsNocheck,
        bootstrapWkt,
        rewriteImports,
        importExtension,
        keepEmptyFiles,
        pluginParameter,
    };
}
function splitParameter(parameter) {
    if (parameter == undefined) {
        return [];
    }
    return parameter.split(",").map((raw) => {
        const i = raw.indexOf("=");
        return {
            key: i === -1 ? raw : raw.substring(0, i),
            value: i === -1 ? "" : raw.substring(i + 1),
            raw,
        };
    });
}
