// Copyright 2021-2023 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { proto3, BinaryReader, ScalarType, } from "@bufbuild/protobuf";
/**
 * Returns the value of a custom option with a scalar type.
 *
 * If no option is found, returns undefined.
 */
export function findCustomScalarOption(desc, extensionNumber, scalarType) {
    const reader = createBinaryReader(desc, extensionNumber);
    if (reader) {
        switch (scalarType) {
            case ScalarType.INT32:
                return reader.int32();
            case ScalarType.UINT32:
                return reader.uint32();
            case ScalarType.SINT32:
                return reader.sint32();
            case ScalarType.FIXED32:
                return reader.fixed32();
            case ScalarType.SFIXED32:
                return reader.sfixed32();
            case ScalarType.FLOAT:
                return reader.float();
            case ScalarType.DOUBLE:
                return reader.double();
            case ScalarType.INT64:
                return reader.int64();
            case ScalarType.SINT64:
                return reader.sint64();
            case ScalarType.SFIXED64:
                return reader.sfixed64();
            case ScalarType.UINT64:
                return reader.uint64();
            case ScalarType.FIXED64:
                return reader.fixed64();
            case ScalarType.BOOL:
                return reader.bool();
            case ScalarType.BYTES:
                return reader.bytes();
            case ScalarType.STRING:
                return reader.string();
            default: {
                break;
            }
        }
    }
    return undefined;
}
/**
 * Returns the value of a custom message option for the given descriptor and
 * extension number.
 * The msgType param is then used to deserialize the message for returning to
 * the caller.
 *
 * If no options are found, returns undefined.
 *
 * If the message option is unable to be read or deserialized, an error will
 * be thrown.
 */
export function findCustomMessageOption(desc, extensionNumber, msgType) {
    const reader = createBinaryReader(desc, extensionNumber);
    if (reader) {
        try {
            const data = reader.bytes();
            return msgType.fromBinary(data);
        }
        catch (e) {
            const innerMessage = e instanceof Error ? e.message : String(e);
            throw new Error(`failed to access message option: ${innerMessage}`);
        }
    }
    return undefined;
}
/**
 * Returns the value of a custom enum option for the given descriptor and
 * extension number.
 *
 * If no options are found, returns undefined.
 */
export function findCustomEnumOption(desc, extensionNumber) {
    return findCustomScalarOption(desc, extensionNumber, ScalarType.INT32);
}
/**
 * Returns a binary reader for the given descriptor and extension number.
 */
function createBinaryReader(desc, extensionNumber) {
    const opt = desc.proto.options;
    let reader = undefined;
    if (opt !== undefined) {
        const unknownFields = proto3.bin.listUnknownFields(opt);
        const field = unknownFields.find((f) => f.no === extensionNumber);
        if (field) {
            reader = new BinaryReader(field.data);
        }
    }
    return reader;
}
