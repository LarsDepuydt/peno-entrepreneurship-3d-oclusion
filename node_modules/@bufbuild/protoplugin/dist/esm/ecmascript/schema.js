// Copyright 2021-2023 Buf Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
import { CodeGeneratorResponse, CodeGeneratorResponse_Feature, codegenInfo, createDescriptorSet, protoInt64, } from "@bufbuild/protobuf";
import { createGeneratedFile } from "./generated-file.js";
import { createRuntimeImports } from "./runtime-imports.js";
import { createImportSymbol } from "./import-symbol.js";
import { deriveImportPath, makeImportPath, rewriteImportPath, } from "./import-path.js";
export function createSchema(request, targets, tsNocheck, bootstrapWkt, rewriteImports, importExtension, keepEmptyFiles, pluginName, pluginVersion, pluginParameter) {
    const descriptorSet = createDescriptorSet(request.protoFile);
    const filesToGenerate = findFilesToGenerate(descriptorSet, request);
    const runtime = createRuntimeImports(bootstrapWkt);
    const createTypeImport = (desc) => {
        const name = codegenInfo.localName(desc);
        const from = makeImportPath(desc.file, bootstrapWkt, filesToGenerate);
        return createImportSymbol(name, from);
    };
    const generatedFiles = [];
    const schema = {
        targets,
        runtime,
        proto: request,
        files: filesToGenerate,
        allFiles: descriptorSet.files,
        generateFile(name) {
            const genFile = createGeneratedFile(name, deriveImportPath(name), (importPath) => rewriteImportPath(importPath, rewriteImports, importExtension), createTypeImport, runtime, {
                pluginName,
                pluginVersion,
                pluginParameter,
                tsNocheck,
            }, keepEmptyFiles);
            generatedFiles.push(genFile);
            return genFile;
        },
    };
    return {
        schema,
        getFileInfo() {
            return generatedFiles.flatMap((file) => {
                const fileInfo = file.getFileInfo();
                // undefined is returned if the file has no content
                if (!fileInfo) {
                    return [];
                }
                return [fileInfo];
            });
        },
    };
}
export function toResponse(files) {
    return new CodeGeneratorResponse({
        supportedFeatures: protoInt64.parse(CodeGeneratorResponse_Feature.PROTO3_OPTIONAL),
        file: files.map((f) => {
            if (f.preamble !== undefined) {
                f.content = f.preamble + "\n" + f.content;
            }
            return f;
        }),
    });
}
function findFilesToGenerate(descriptorSet, request) {
    const missing = request.fileToGenerate.filter((fileToGenerate) => descriptorSet.files.every((file) => fileToGenerate !== file.name + ".proto"));
    if (missing.length) {
        throw `files_to_generate missing in the request: ${missing.join(", ")}`;
    }
    return descriptorSet.files.filter((file) => request.fileToGenerate.includes(file.name + ".proto"));
}
