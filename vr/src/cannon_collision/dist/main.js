(()=>{"use strict";var t={};t.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{var e;t.g.importScripts&&(e=t.g.location+"");var s=t.g.document;if(!e&&s&&(s.currentScript&&(e=s.currentScript.src),!e)){var i=s.getElementsByTagName("script");if(i.length)for(var n=i.length-1;n>-1&&!e;)e=i[n--].src}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),t.p=e})();class e{constructor(t){void 0===t&&(t=[0,0,0,0,0,0,0,0,0]),this.elements=t}identity(){const t=this.elements;t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=1,t[5]=0,t[6]=0,t[7]=0,t[8]=1}setZero(){const t=this.elements;t[0]=0,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=0,t[6]=0,t[7]=0,t[8]=0}setTrace(t){const e=this.elements;e[0]=t.x,e[4]=t.y,e[8]=t.z}getTrace(t){void 0===t&&(t=new i);const e=this.elements;return t.x=e[0],t.y=e[4],t.z=e[8],t}vmult(t,e){void 0===e&&(e=new i);const s=this.elements,n=t.x,o=t.y,r=t.z;return e.x=s[0]*n+s[1]*o+s[2]*r,e.y=s[3]*n+s[4]*o+s[5]*r,e.z=s[6]*n+s[7]*o+s[8]*r,e}smult(t){for(let e=0;e<this.elements.length;e++)this.elements[e]*=t}mmult(t,s){void 0===s&&(s=new e);const i=this.elements,n=t.elements,o=s.elements,r=i[0],a=i[1],h=i[2],l=i[3],c=i[4],u=i[5],d=i[6],p=i[7],w=i[8],y=n[0],m=n[1],v=n[2],f=n[3],x=n[4],g=n[5],z=n[6],E=n[7],b=n[8];return o[0]=r*y+a*f+h*z,o[1]=r*m+a*x+h*E,o[2]=r*v+a*g+h*b,o[3]=l*y+c*f+u*z,o[4]=l*m+c*x+u*E,o[5]=l*v+c*g+u*b,o[6]=d*y+p*f+w*z,o[7]=d*m+p*x+w*E,o[8]=d*v+p*g+w*b,s}scale(t,s){void 0===s&&(s=new e);const i=this.elements,n=s.elements;for(let e=0;3!==e;e++)n[3*e+0]=t.x*i[3*e+0],n[3*e+1]=t.y*i[3*e+1],n[3*e+2]=t.z*i[3*e+2];return s}solve(t,e){void 0===e&&(e=new i);const s=[];let n,o;for(n=0;n<12;n++)s.push(0);for(n=0;n<3;n++)for(o=0;o<3;o++)s[n+4*o]=this.elements[n+3*o];s[3]=t.x,s[7]=t.y,s[11]=t.z;let r=3;const a=r;let h,l;do{if(n=a-r,0===s[n+4*n])for(o=n+1;o<a;o++)if(0!==s[n+4*o]){h=4;do{l=4-h,s[l+4*n]+=s[l+4*o]}while(--h);break}if(0!==s[n+4*n])for(o=n+1;o<a;o++){const t=s[n+4*o]/s[n+4*n];h=4;do{l=4-h,s[l+4*o]=l<=n?0:s[l+4*o]-s[l+4*n]*t}while(--h)}}while(--r);if(e.z=s[11]/s[10],e.y=(s[7]-s[6]*e.z)/s[5],e.x=(s[3]-s[2]*e.z-s[1]*e.y)/s[0],isNaN(e.x)||isNaN(e.y)||isNaN(e.z)||e.x===1/0||e.y===1/0||e.z===1/0)throw`Could not solve equation! Got x=[${e.toString()}], b=[${t.toString()}], A=[${this.toString()}]`;return e}e(t,e,s){if(void 0===s)return this.elements[e+3*t];this.elements[e+3*t]=s}copy(t){for(let e=0;e<t.elements.length;e++)this.elements[e]=t.elements[e];return this}toString(){let t="";for(let e=0;e<9;e++)t+=this.elements[e]+",";return t}reverse(t){void 0===t&&(t=new e);const i=s;let n,o;for(n=0;n<3;n++)for(o=0;o<3;o++)i[n+6*o]=this.elements[n+3*o];i[3]=1,i[9]=0,i[15]=0,i[4]=0,i[10]=1,i[16]=0,i[5]=0,i[11]=0,i[17]=1;let r=3;const a=r;let h,l;do{if(n=a-r,0===i[n+6*n])for(o=n+1;o<a;o++)if(0!==i[n+6*o]){h=6;do{l=6-h,i[l+6*n]+=i[l+6*o]}while(--h);break}if(0!==i[n+6*n])for(o=n+1;o<a;o++){const t=i[n+6*o]/i[n+6*n];h=6;do{l=6-h,i[l+6*o]=l<=n?0:i[l+6*o]-i[l+6*n]*t}while(--h)}}while(--r);n=2;do{o=n-1;do{const t=i[n+6*o]/i[n+6*n];h=6;do{l=6-h,i[l+6*o]=i[l+6*o]-i[l+6*n]*t}while(--h)}while(o--)}while(--n);n=2;do{const t=1/i[n+6*n];h=6;do{l=6-h,i[l+6*n]=i[l+6*n]*t}while(--h)}while(n--);n=2;do{o=2;do{if(l=i[3+o+6*n],isNaN(l)||l===1/0)throw`Could not reverse! A=[${this.toString()}]`;t.e(n,o,l)}while(o--)}while(n--);return t}setRotationFromQuaternion(t){const e=t.x,s=t.y,i=t.z,n=t.w,o=e+e,r=s+s,a=i+i,h=e*o,l=e*r,c=e*a,u=s*r,d=s*a,p=i*a,w=n*o,y=n*r,m=n*a,v=this.elements;return v[0]=1-(u+p),v[1]=l-m,v[2]=c+y,v[3]=l+m,v[4]=1-(h+p),v[5]=d-w,v[6]=c-y,v[7]=d+w,v[8]=1-(h+u),this}transpose(t){void 0===t&&(t=new e);const s=this.elements,i=t.elements;let n;return i[0]=s[0],i[4]=s[4],i[8]=s[8],n=s[1],i[1]=s[3],i[3]=n,n=s[2],i[2]=s[6],i[6]=n,n=s[5],i[5]=s[7],i[7]=n,t}}const s=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class i{constructor(t,e,s){void 0===t&&(t=0),void 0===e&&(e=0),void 0===s&&(s=0),this.x=t,this.y=e,this.z=s}cross(t,e){void 0===e&&(e=new i);const s=t.x,n=t.y,o=t.z,r=this.x,a=this.y,h=this.z;return e.x=a*o-h*n,e.y=h*s-r*o,e.z=r*n-a*s,e}set(t,e,s){return this.x=t,this.y=e,this.z=s,this}setZero(){this.x=this.y=this.z=0}vadd(t,e){if(!e)return new i(this.x+t.x,this.y+t.y,this.z+t.z);e.x=t.x+this.x,e.y=t.y+this.y,e.z=t.z+this.z}vsub(t,e){if(!e)return new i(this.x-t.x,this.y-t.y,this.z-t.z);e.x=this.x-t.x,e.y=this.y-t.y,e.z=this.z-t.z}crossmat(){return new e([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const t=this.x,e=this.y,s=this.z,i=Math.sqrt(t*t+e*e+s*s);if(i>0){const t=1/i;this.x*=t,this.y*=t,this.z*=t}else this.x=0,this.y=0,this.z=0;return i}unit(t){void 0===t&&(t=new i);const e=this.x,s=this.y,n=this.z;let o=Math.sqrt(e*e+s*s+n*n);return o>0?(o=1/o,t.x=e*o,t.y=s*o,t.z=n*o):(t.x=1,t.y=0,t.z=0),t}length(){const t=this.x,e=this.y,s=this.z;return Math.sqrt(t*t+e*e+s*s)}lengthSquared(){return this.dot(this)}distanceTo(t){const e=this.x,s=this.y,i=this.z,n=t.x,o=t.y,r=t.z;return Math.sqrt((n-e)*(n-e)+(o-s)*(o-s)+(r-i)*(r-i))}distanceSquared(t){const e=this.x,s=this.y,i=this.z,n=t.x,o=t.y,r=t.z;return(n-e)*(n-e)+(o-s)*(o-s)+(r-i)*(r-i)}scale(t,e){void 0===e&&(e=new i);const s=this.x,n=this.y,o=this.z;return e.x=t*s,e.y=t*n,e.z=t*o,e}vmul(t,e){return void 0===e&&(e=new i),e.x=t.x*this.x,e.y=t.y*this.y,e.z=t.z*this.z,e}addScaledVector(t,e,s){return void 0===s&&(s=new i),s.x=this.x+t*e.x,s.y=this.y+t*e.y,s.z=this.z+t*e.z,s}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(t){return void 0===t&&(t=new i),t.x=-this.x,t.y=-this.y,t.z=-this.z,t}tangents(t,e){const s=this.length();if(s>0){const i=n,r=1/s;i.set(this.x*r,this.y*r,this.z*r);const a=o;Math.abs(i.x)<.9?(a.set(1,0,0),i.cross(a,t)):(a.set(0,1,0),i.cross(a,t)),i.cross(t,e)}else t.set(1,0,0),e.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}lerp(t,e,s){const i=this.x,n=this.y,o=this.z;s.x=i+(t.x-i)*e,s.y=n+(t.y-n)*e,s.z=o+(t.z-o)*e}almostEquals(t,e){return void 0===e&&(e=1e-6),!(Math.abs(this.x-t.x)>e||Math.abs(this.y-t.y)>e||Math.abs(this.z-t.z)>e)}almostZero(t){return void 0===t&&(t=1e-6),!(Math.abs(this.x)>t||Math.abs(this.y)>t||Math.abs(this.z)>t)}isAntiparallelTo(t,e){return this.negate(r),r.almostEquals(t,e)}clone(){return new i(this.x,this.y,this.z)}}i.ZERO=new i(0,0,0),i.UNIT_X=new i(1,0,0),i.UNIT_Y=new i(0,1,0),i.UNIT_Z=new i(0,0,1);const n=new i,o=new i,r=new i;class a{constructor(t){void 0===t&&(t={}),this.lowerBound=new i,this.upperBound=new i,t.lowerBound&&this.lowerBound.copy(t.lowerBound),t.upperBound&&this.upperBound.copy(t.upperBound)}setFromPoints(t,e,s,i){const n=this.lowerBound,o=this.upperBound,r=s;n.copy(t[0]),r&&r.vmult(n,n),o.copy(n);for(let e=1;e<t.length;e++){let s=t[e];r&&(r.vmult(s,h),s=h),s.x>o.x&&(o.x=s.x),s.x<n.x&&(n.x=s.x),s.y>o.y&&(o.y=s.y),s.y<n.y&&(n.y=s.y),s.z>o.z&&(o.z=s.z),s.z<n.z&&(n.z=s.z)}return e&&(e.vadd(n,n),e.vadd(o,o)),i&&(n.x-=i,n.y-=i,n.z-=i,o.x+=i,o.y+=i,o.z+=i),this}copy(t){return this.lowerBound.copy(t.lowerBound),this.upperBound.copy(t.upperBound),this}clone(){return(new a).copy(this)}extend(t){this.lowerBound.x=Math.min(this.lowerBound.x,t.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,t.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,t.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,t.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,t.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,t.upperBound.z)}overlaps(t){const e=this.lowerBound,s=this.upperBound,i=t.lowerBound,n=t.upperBound,o=i.x<=s.x&&s.x<=n.x||e.x<=n.x&&n.x<=s.x,r=i.y<=s.y&&s.y<=n.y||e.y<=n.y&&n.y<=s.y,a=i.z<=s.z&&s.z<=n.z||e.z<=n.z&&n.z<=s.z;return o&&r&&a}volume(){const t=this.lowerBound,e=this.upperBound;return(e.x-t.x)*(e.y-t.y)*(e.z-t.z)}contains(t){const e=this.lowerBound,s=this.upperBound,i=t.lowerBound,n=t.upperBound;return e.x<=i.x&&s.x>=n.x&&e.y<=i.y&&s.y>=n.y&&e.z<=i.z&&s.z>=n.z}getCorners(t,e,s,i,n,o,r,a){const h=this.lowerBound,l=this.upperBound;t.copy(h),e.set(l.x,h.y,h.z),s.set(l.x,l.y,h.z),i.set(h.x,l.y,l.z),n.set(l.x,h.y,l.z),o.set(h.x,l.y,h.z),r.set(h.x,h.y,l.z),a.copy(l)}toLocalFrame(t,e){const s=l,i=s[0],n=s[1],o=s[2],r=s[3],a=s[4],h=s[5],c=s[6],u=s[7];this.getCorners(i,n,o,r,a,h,c,u);for(let e=0;8!==e;e++){const i=s[e];t.pointToLocal(i,i)}return e.setFromPoints(s)}toWorldFrame(t,e){const s=l,i=s[0],n=s[1],o=s[2],r=s[3],a=s[4],h=s[5],c=s[6],u=s[7];this.getCorners(i,n,o,r,a,h,c,u);for(let e=0;8!==e;e++){const i=s[e];t.pointToWorld(i,i)}return e.setFromPoints(s)}overlapsRay(t){const{direction:e,from:s}=t,i=1/e.x,n=1/e.y,o=1/e.z,r=(this.lowerBound.x-s.x)*i,a=(this.upperBound.x-s.x)*i,h=(this.lowerBound.y-s.y)*n,l=(this.upperBound.y-s.y)*n,c=(this.lowerBound.z-s.z)*o,u=(this.upperBound.z-s.z)*o,d=Math.max(Math.max(Math.min(r,a),Math.min(h,l)),Math.min(c,u)),p=Math.min(Math.min(Math.max(r,a),Math.max(h,l)),Math.max(c,u));return!(p<0||d>p)}}const h=new i,l=[new i,new i,new i,new i,new i,new i,new i,new i];class c{addEventListener(t,e){void 0===this._listeners&&(this._listeners={});const s=this._listeners;return void 0===s[t]&&(s[t]=[]),s[t].includes(e)||s[t].push(e),this}hasEventListener(t,e){if(void 0===this._listeners)return!1;const s=this._listeners;return!(void 0===s[t]||!s[t].includes(e))}hasAnyEventListener(t){return void 0!==this._listeners&&void 0!==this._listeners[t]}removeEventListener(t,e){if(void 0===this._listeners)return this;const s=this._listeners;if(void 0===s[t])return this;const i=s[t].indexOf(e);return-1!==i&&s[t].splice(i,1),this}dispatchEvent(t){if(void 0===this._listeners)return this;const e=this._listeners[t.type];if(void 0!==e){t.target=this;for(let s=0,i=e.length;s<i;s++)e[s].call(this,t)}return this}}class u{constructor(t,e,s,i){void 0===t&&(t=0),void 0===e&&(e=0),void 0===s&&(s=0),void 0===i&&(i=1),this.x=t,this.y=e,this.z=s,this.w=i}set(t,e,s,i){return this.x=t,this.y=e,this.z=s,this.w=i,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(t,e){const s=Math.sin(.5*e);return this.x=t.x*s,this.y=t.y*s,this.z=t.z*s,this.w=Math.cos(.5*e),this}toAxisAngle(t){void 0===t&&(t=new i),this.normalize();const e=2*Math.acos(this.w),s=Math.sqrt(1-this.w*this.w);return s<.001?(t.x=this.x,t.y=this.y,t.z=this.z):(t.x=this.x/s,t.y=this.y/s,t.z=this.z/s),[t,e]}setFromVectors(t,e){if(t.isAntiparallelTo(e)){const e=d,s=p;t.tangents(e,s),this.setFromAxisAngle(e,Math.PI)}else{const s=t.cross(e);this.x=s.x,this.y=s.y,this.z=s.z,this.w=Math.sqrt(t.length()**2*e.length()**2)+t.dot(e),this.normalize()}return this}mult(t,e){void 0===e&&(e=new u);const s=this.x,i=this.y,n=this.z,o=this.w,r=t.x,a=t.y,h=t.z,l=t.w;return e.x=s*l+o*r+i*h-n*a,e.y=i*l+o*a+n*r-s*h,e.z=n*l+o*h+s*a-i*r,e.w=o*l-s*r-i*a-n*h,e}inverse(t){void 0===t&&(t=new u);const e=this.x,s=this.y,i=this.z,n=this.w;this.conjugate(t);const o=1/(e*e+s*s+i*i+n*n);return t.x*=o,t.y*=o,t.z*=o,t.w*=o,t}conjugate(t){return void 0===t&&(t=new u),t.x=-this.x,t.y=-this.y,t.z=-this.z,t.w=this.w,t}normalize(){let t=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===t?(this.x=0,this.y=0,this.z=0,this.w=0):(t=1/t,this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}normalizeFast(){const t=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===t?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=t,this.y*=t,this.z*=t,this.w*=t),this}vmult(t,e){void 0===e&&(e=new i);const s=t.x,n=t.y,o=t.z,r=this.x,a=this.y,h=this.z,l=this.w,c=l*s+a*o-h*n,u=l*n+h*s-r*o,d=l*o+r*n-a*s,p=-r*s-a*n-h*o;return e.x=c*l+p*-r+u*-h-d*-a,e.y=u*l+p*-a+d*-r-c*-h,e.z=d*l+p*-h+c*-a-u*-r,e}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}toEuler(t,e){let s,i,n;void 0===e&&(e="YZX");const o=this.x,r=this.y,a=this.z,h=this.w;if("YZX"!==e)throw new Error(`Euler order ${e} not supported yet.`);{const t=o*r+a*h;if(t>.499&&(s=2*Math.atan2(o,h),i=Math.PI/2,n=0),t<-.499&&(s=-2*Math.atan2(o,h),i=-Math.PI/2,n=0),void 0===s){const e=o*o,l=r*r,c=a*a;s=Math.atan2(2*r*h-2*o*a,1-2*l-2*c),i=Math.asin(2*t),n=Math.atan2(2*o*h-2*r*a,1-2*e-2*c)}}t.y=s,t.z=i,t.x=n}setFromEuler(t,e,s,i){void 0===i&&(i="XYZ");const n=Math.cos(t/2),o=Math.cos(e/2),r=Math.cos(s/2),a=Math.sin(t/2),h=Math.sin(e/2),l=Math.sin(s/2);return"XYZ"===i?(this.x=a*o*r+n*h*l,this.y=n*h*r-a*o*l,this.z=n*o*l+a*h*r,this.w=n*o*r-a*h*l):"YXZ"===i?(this.x=a*o*r+n*h*l,this.y=n*h*r-a*o*l,this.z=n*o*l-a*h*r,this.w=n*o*r+a*h*l):"ZXY"===i?(this.x=a*o*r-n*h*l,this.y=n*h*r+a*o*l,this.z=n*o*l+a*h*r,this.w=n*o*r-a*h*l):"ZYX"===i?(this.x=a*o*r-n*h*l,this.y=n*h*r+a*o*l,this.z=n*o*l-a*h*r,this.w=n*o*r+a*h*l):"YZX"===i?(this.x=a*o*r+n*h*l,this.y=n*h*r+a*o*l,this.z=n*o*l-a*h*r,this.w=n*o*r-a*h*l):"XZY"===i&&(this.x=a*o*r-n*h*l,this.y=n*h*r-a*o*l,this.z=n*o*l+a*h*r,this.w=n*o*r+a*h*l),this}clone(){return new u(this.x,this.y,this.z,this.w)}slerp(t,e,s){void 0===s&&(s=new u);const i=this.x,n=this.y,o=this.z,r=this.w;let a,h,l,c,d,p=t.x,w=t.y,y=t.z,m=t.w;return h=i*p+n*w+o*y+r*m,h<0&&(h=-h,p=-p,w=-w,y=-y,m=-m),1-h>1e-6?(a=Math.acos(h),l=Math.sin(a),c=Math.sin((1-e)*a)/l,d=Math.sin(e*a)/l):(c=1-e,d=e),s.x=c*i+d*p,s.y=c*n+d*w,s.z=c*o+d*y,s.w=c*r+d*m,s}integrate(t,e,s,i){void 0===i&&(i=new u);const n=t.x*s.x,o=t.y*s.y,r=t.z*s.z,a=this.x,h=this.y,l=this.z,c=this.w,d=.5*e;return i.x+=d*(n*c+o*l-r*h),i.y+=d*(o*c+r*a-n*l),i.z+=d*(r*c+n*h-o*a),i.w+=d*(-n*a-o*h-r*l),i}}const d=new i,p=new i;class w{constructor(t){void 0===t&&(t={}),this.id=w.idCounter++,this.type=t.type||0,this.boundingSphereRadius=0,this.collisionResponse=!t.collisionResponse||t.collisionResponse,this.collisionFilterGroup=void 0!==t.collisionFilterGroup?t.collisionFilterGroup:1,this.collisionFilterMask=void 0!==t.collisionFilterMask?t.collisionFilterMask:-1,this.material=t.material?t.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(t,e){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(t,e,s,i){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}w.idCounter=0,w.types={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class y{constructor(t){void 0===t&&(t={}),this.position=new i,this.quaternion=new u,t.position&&this.position.copy(t.position),t.quaternion&&this.quaternion.copy(t.quaternion)}pointToLocal(t,e){return y.pointToLocalFrame(this.position,this.quaternion,t,e)}pointToWorld(t,e){return y.pointToWorldFrame(this.position,this.quaternion,t,e)}vectorToWorldFrame(t,e){return void 0===e&&(e=new i),this.quaternion.vmult(t,e),e}static pointToLocalFrame(t,e,s,n){return void 0===n&&(n=new i),s.vsub(t,n),e.conjugate(m),m.vmult(n,n),n}static pointToWorldFrame(t,e,s,n){return void 0===n&&(n=new i),e.vmult(s,n),n.vadd(t,n),n}static vectorToWorldFrame(t,e,s){return void 0===s&&(s=new i),t.vmult(e,s),s}static vectorToLocalFrame(t,e,s,n){return void 0===n&&(n=new i),e.w*=-1,e.vmult(s,n),e.w*=-1,n}}const m=new u;class v extends w{constructor(t){void 0===t&&(t={});const{vertices:e=[],faces:s=[],normals:i=[],axes:n,boundingSphereRadius:o}=t;super({type:w.types.CONVEXPOLYHEDRON}),this.vertices=e,this.faces=s,this.faceNormals=i,0===this.faceNormals.length&&this.computeNormals(),o?this.boundingSphereRadius=o:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=n?n.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const t=this.faces,e=this.vertices,s=this.uniqueEdges;s.length=0;const n=new i;for(let i=0;i!==t.length;i++){const o=t[i],r=o.length;for(let t=0;t!==r;t++){const i=(t+1)%r;e[o[t]].vsub(e[o[i]],n),n.normalize();let a=!1;for(let t=0;t!==s.length;t++)if(s[t].almostEquals(n)||s[t].almostEquals(n)){a=!0;break}a||s.push(n.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let t=0;t<this.faces.length;t++){for(let e=0;e<this.faces[t].length;e++)if(!this.vertices[this.faces[t][e]])throw new Error(`Vertex ${this.faces[t][e]} not found!`);const e=this.faceNormals[t]||new i;this.getFaceNormal(t,e),e.negate(e),this.faceNormals[t]=e;const s=this.vertices[this.faces[t][0]];if(e.dot(s)<0){console.error(`.faceNormals[${t}] = Vec3(${e.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let e=0;e<this.faces[t].length;e++)console.warn(`.vertices[${this.faces[t][e]}] = Vec3(${this.vertices[this.faces[t][e]].toString()})`)}}}getFaceNormal(t,e){const s=this.faces[t],i=this.vertices[s[0]],n=this.vertices[s[1]],o=this.vertices[s[2]];v.computeNormal(i,n,o,e)}static computeNormal(t,e,s,n){const o=new i,r=new i;e.vsub(t,r),s.vsub(e,o),o.cross(r,n),n.isZero()||n.normalize()}clipAgainstHull(t,e,s,n,o,r,a,h,l){const c=new i;let u=-1,d=-Number.MAX_VALUE;for(let t=0;t<s.faces.length;t++){c.copy(s.faceNormals[t]),o.vmult(c,c);const e=c.dot(r);e>d&&(d=e,u=t)}const p=[];for(let t=0;t<s.faces[u].length;t++){const e=s.vertices[s.faces[u][t]],r=new i;r.copy(e),o.vmult(r,r),n.vadd(r,r),p.push(r)}u>=0&&this.clipFaceAgainstHull(r,t,e,p,a,h,l)}findSeparatingAxis(t,e,s,n,o,r,a,h){const l=new i,c=new i,u=new i,d=new i,p=new i,w=new i;let y=Number.MAX_VALUE;const m=this;if(m.uniqueAxes)for(let i=0;i!==m.uniqueAxes.length;i++){s.vmult(m.uniqueAxes[i],l);const a=m.testSepAxis(l,t,e,s,n,o);if(!1===a)return!1;a<y&&(y=a,r.copy(l))}else{const i=a?a.length:m.faces.length;for(let h=0;h<i;h++){const i=a?a[h]:h;l.copy(m.faceNormals[i]),s.vmult(l,l);const c=m.testSepAxis(l,t,e,s,n,o);if(!1===c)return!1;c<y&&(y=c,r.copy(l))}}if(t.uniqueAxes)for(let i=0;i!==t.uniqueAxes.length;i++){o.vmult(t.uniqueAxes[i],c);const a=m.testSepAxis(c,t,e,s,n,o);if(!1===a)return!1;a<y&&(y=a,r.copy(c))}else{const i=h?h.length:t.faces.length;for(let a=0;a<i;a++){const i=h?h[a]:a;c.copy(t.faceNormals[i]),o.vmult(c,c);const l=m.testSepAxis(c,t,e,s,n,o);if(!1===l)return!1;l<y&&(y=l,r.copy(c))}}for(let i=0;i!==m.uniqueEdges.length;i++){s.vmult(m.uniqueEdges[i],d);for(let i=0;i!==t.uniqueEdges.length;i++)if(o.vmult(t.uniqueEdges[i],p),d.cross(p,w),!w.almostZero()){w.normalize();const i=m.testSepAxis(w,t,e,s,n,o);if(!1===i)return!1;i<y&&(y=i,r.copy(w))}}return n.vsub(e,u),u.dot(r)>0&&r.negate(r),!0}testSepAxis(t,e,s,i,n,o){v.project(this,t,s,i,f),v.project(e,t,n,o,x);const r=f[0],a=f[1],h=x[0],l=x[1];if(r<l||h<a)return!1;const c=r-l,u=h-a;return c<u?c:u}calculateLocalInertia(t,e){const s=new i,n=new i;this.computeLocalAABB(n,s);const o=s.x-n.x,r=s.y-n.y,a=s.z-n.z;e.x=1/12*t*(2*r*2*r+2*a*2*a),e.y=1/12*t*(2*o*2*o+2*a*2*a),e.z=1/12*t*(2*r*2*r+2*o*2*o)}getPlaneConstantOfFace(t){const e=this.faces[t],s=this.faceNormals[t],i=this.vertices[e[0]];return-s.dot(i)}clipFaceAgainstHull(t,e,s,n,o,r,a){const h=new i,l=new i,c=new i,u=new i,d=new i,p=new i,w=new i,y=new i,m=this,v=n,f=[];let x=-1,g=Number.MAX_VALUE;for(let e=0;e<m.faces.length;e++){h.copy(m.faceNormals[e]),s.vmult(h,h);const i=h.dot(t);i<g&&(g=i,x=e)}if(x<0)return;const z=m.faces[x];z.connectedFaces=[];for(let t=0;t<m.faces.length;t++)for(let e=0;e<m.faces[t].length;e++)-1!==z.indexOf(m.faces[t][e])&&t!==x&&-1===z.connectedFaces.indexOf(t)&&z.connectedFaces.push(t);const E=z.length;for(let t=0;t<E;t++){const i=m.vertices[z[t]],n=m.vertices[z[(t+1)%E]];i.vsub(n,l),c.copy(l),s.vmult(c,c),e.vadd(c,c),u.copy(this.faceNormals[x]),s.vmult(u,u),e.vadd(u,u),c.cross(u,d),d.negate(d),p.copy(i),s.vmult(p,p),e.vadd(p,p);const o=z.connectedFaces[t];w.copy(this.faceNormals[o]);const r=this.getPlaneConstantOfFace(o);y.copy(w),s.vmult(y,y);const a=r-y.dot(e);for(this.clipFaceAgainstPlane(v,f,y,a);v.length;)v.shift();for(;f.length;)v.push(f.shift())}w.copy(this.faceNormals[x]);const b=this.getPlaneConstantOfFace(x);y.copy(w),s.vmult(y,y);const S=b-y.dot(e);for(let t=0;t<v.length;t++){let e=y.dot(v[t])+S;if(e<=o&&(console.log(`clamped: depth=${e} to minDist=${o}`),e=o),e<=r){const s=v[t];if(e<=1e-6){const t={point:s,normal:y,depth:e};a.push(t)}}}}clipFaceAgainstPlane(t,e,s,n){let o,r;const a=t.length;if(a<2)return e;let h=t[t.length-1],l=t[0];o=s.dot(h)+n;for(let c=0;c<a;c++){if(l=t[c],r=s.dot(l)+n,o<0)if(r<0){const t=new i;t.copy(l),e.push(t)}else{const t=new i;h.lerp(l,o/(o-r),t),e.push(t)}else if(r<0){const t=new i;h.lerp(l,o/(o-r),t),e.push(t),e.push(l)}h=l,o=r}return e}computeWorldVertices(t,e){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new i);const s=this.vertices,n=this.worldVertices;for(let i=0;i!==this.vertices.length;i++)e.vmult(s[i],n[i]),t.vadd(n[i],n[i]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(t,e){const s=this.vertices;t.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),e.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let i=0;i<this.vertices.length;i++){const n=s[i];n.x<t.x?t.x=n.x:n.x>e.x&&(e.x=n.x),n.y<t.y?t.y=n.y:n.y>e.y&&(e.y=n.y),n.z<t.z?t.z=n.z:n.z>e.z&&(e.z=n.z)}}computeWorldFaceNormals(t){const e=this.faceNormals.length;for(;this.worldFaceNormals.length<e;)this.worldFaceNormals.push(new i);const s=this.faceNormals,n=this.worldFaceNormals;for(let i=0;i!==e;i++)t.vmult(s[i],n[i]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let t=0;const e=this.vertices;for(let s=0;s!==e.length;s++){const i=e[s].lengthSquared();i>t&&(t=i)}this.boundingSphereRadius=Math.sqrt(t)}calculateWorldAABB(t,e,s,n){const o=this.vertices;let r,a,h,l,c,u,d=new i;for(let s=0;s<o.length;s++){d.copy(o[s]),e.vmult(d,d),t.vadd(d,d);const i=d;(void 0===r||i.x<r)&&(r=i.x),(void 0===l||i.x>l)&&(l=i.x),(void 0===a||i.y<a)&&(a=i.y),(void 0===c||i.y>c)&&(c=i.y),(void 0===h||i.z<h)&&(h=i.z),(void 0===u||i.z>u)&&(u=i.z)}s.set(r,a,h),n.set(l,c,u)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(t){void 0===t&&(t=new i);const e=this.vertices;for(let s=0;s<e.length;s++)t.vadd(e[s],t);return t.scale(1/e.length,t),t}transformAllPoints(t,e){const s=this.vertices.length,i=this.vertices;if(e){for(let t=0;t<s;t++){const s=i[t];e.vmult(s,s)}for(let t=0;t<this.faceNormals.length;t++){const s=this.faceNormals[t];e.vmult(s,s)}}if(t)for(let e=0;e<s;e++){const s=i[e];s.vadd(t,s)}}pointIsInside(t){const e=this.vertices,s=this.faces,n=this.faceNormals,o=new i;this.getAveragePointLocal(o);for(let r=0;r<this.faces.length;r++){let a=n[r];const h=e[s[r][0]],l=new i;t.vsub(h,l);const c=a.dot(l),u=new i;o.vsub(h,u);const d=a.dot(u);if(c<0&&d>0||c>0&&d<0)return!1}return-1}static project(t,e,s,i,n){const o=t.vertices.length,r=g;let a=0,h=0;const l=z,c=t.vertices;l.setZero(),y.vectorToLocalFrame(s,i,e,r),y.pointToLocalFrame(s,i,l,l);const u=l.dot(r);h=a=c[0].dot(r);for(let t=1;t<o;t++){const e=c[t].dot(r);e>a&&(a=e),e<h&&(h=e)}if(h-=u,a-=u,h>a){const t=h;h=a,a=t}n[0]=a,n[1]=h}}const f=[],x=[],g=(new i,new i),z=new i;class E extends w{constructor(t){super({type:w.types.BOX}),this.halfExtents=t,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const t=this.halfExtents.x,e=this.halfExtents.y,s=this.halfExtents.z,n=i,o=[new n(-t,-e,-s),new n(t,-e,-s),new n(t,e,-s),new n(-t,e,-s),new n(-t,-e,s),new n(t,-e,s),new n(t,e,s),new n(-t,e,s)],r=[new n(0,0,1),new n(0,1,0),new n(1,0,0)],a=new v({vertices:o,faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:r});this.convexPolyhedronRepresentation=a,a.material=this.material}calculateLocalInertia(t,e){return void 0===e&&(e=new i),E.calculateInertia(this.halfExtents,t,e),e}static calculateInertia(t,e,s){const i=t;s.x=1/12*e*(2*i.y*2*i.y+2*i.z*2*i.z),s.y=1/12*e*(2*i.x*2*i.x+2*i.z*2*i.z),s.z=1/12*e*(2*i.y*2*i.y+2*i.x*2*i.x)}getSideNormals(t,e){const s=t,i=this.halfExtents;if(s[0].set(i.x,0,0),s[1].set(0,i.y,0),s[2].set(0,0,i.z),s[3].set(-i.x,0,0),s[4].set(0,-i.y,0),s[5].set(0,0,-i.z),void 0!==e)for(let t=0;t!==s.length;t++)e.vmult(s[t],s[t]);return s}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(t,e,s){const i=this.halfExtents,n=[[i.x,i.y,i.z],[-i.x,i.y,i.z],[-i.x,-i.y,i.z],[-i.x,-i.y,-i.z],[i.x,-i.y,-i.z],[i.x,i.y,-i.z],[-i.x,i.y,-i.z],[i.x,-i.y,i.z]];for(let i=0;i<n.length;i++)b.set(n[i][0],n[i][1],n[i][2]),e.vmult(b,b),t.vadd(b,b),s(b.x,b.y,b.z)}calculateWorldAABB(t,e,s,i){const n=this.halfExtents;S[0].set(n.x,n.y,n.z),S[1].set(-n.x,n.y,n.z),S[2].set(-n.x,-n.y,n.z),S[3].set(-n.x,-n.y,-n.z),S[4].set(n.x,-n.y,-n.z),S[5].set(n.x,n.y,-n.z),S[6].set(-n.x,n.y,-n.z),S[7].set(n.x,-n.y,n.z);const o=S[0];e.vmult(o,o),t.vadd(o,o),i.copy(o),s.copy(o);for(let n=1;n<8;n++){const o=S[n];e.vmult(o,o),t.vadd(o,o);const r=o.x,a=o.y,h=o.z;r>i.x&&(i.x=r),a>i.y&&(i.y=a),h>i.z&&(i.z=h),r<s.x&&(s.x=r),a<s.y&&(s.y=a),h<s.z&&(s.z=h)}}}const b=new i,S=[new i,new i,new i,new i,new i,new i,new i,new i];class A extends c{constructor(t){void 0===t&&(t={}),super(),this.id=A.idCounter++,this.index=-1,this.world=null,this.vlambda=new i,this.collisionFilterGroup="number"==typeof t.collisionFilterGroup?t.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof t.collisionFilterMask?t.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof t.collisionResponse||t.collisionResponse,this.position=new i,this.previousPosition=new i,this.interpolatedPosition=new i,this.initPosition=new i,t.position&&(this.position.copy(t.position),this.previousPosition.copy(t.position),this.interpolatedPosition.copy(t.position),this.initPosition.copy(t.position)),this.velocity=new i,t.velocity&&this.velocity.copy(t.velocity),this.initVelocity=new i,this.force=new i;const s="number"==typeof t.mass?t.mass:0;this.mass=s,this.invMass=s>0?1/s:0,this.material=t.material||null,this.linearDamping="number"==typeof t.linearDamping?t.linearDamping:.01,this.type=s<=0?A.STATIC:A.DYNAMIC,typeof t.type==typeof A.STATIC&&(this.type=t.type),this.allowSleep=void 0===t.allowSleep||t.allowSleep,this.sleepState=A.AWAKE,this.sleepSpeedLimit=void 0!==t.sleepSpeedLimit?t.sleepSpeedLimit:.1,this.sleepTimeLimit=void 0!==t.sleepTimeLimit?t.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new i,this.quaternion=new u,this.initQuaternion=new u,this.previousQuaternion=new u,this.interpolatedQuaternion=new u,t.quaternion&&(this.quaternion.copy(t.quaternion),this.initQuaternion.copy(t.quaternion),this.previousQuaternion.copy(t.quaternion),this.interpolatedQuaternion.copy(t.quaternion)),this.angularVelocity=new i,t.angularVelocity&&this.angularVelocity.copy(t.angularVelocity),this.initAngularVelocity=new i,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new i,this.invInertia=new i,this.invInertiaWorld=new e,this.invMassSolve=0,this.invInertiaSolve=new i,this.invInertiaWorldSolve=new e,this.fixedRotation=void 0!==t.fixedRotation&&t.fixedRotation,this.angularDamping=void 0!==t.angularDamping?t.angularDamping:.01,this.linearFactor=new i(1,1,1),t.linearFactor&&this.linearFactor.copy(t.linearFactor),this.angularFactor=new i(1,1,1),t.angularFactor&&this.angularFactor.copy(t.angularFactor),this.aabb=new a,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new i,this.isTrigger=Boolean(t.isTrigger),t.shape&&this.addShape(t.shape),this.updateMassProperties()}wakeUp(){const t=this.sleepState;this.sleepState=A.AWAKE,this.wakeUpAfterNarrowphase=!1,t===A.SLEEPING&&this.dispatchEvent(A.wakeupEvent)}sleep(){this.sleepState=A.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(t){if(this.allowSleep){const e=this.sleepState,s=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),i=this.sleepSpeedLimit**2;e===A.AWAKE&&s<i?(this.sleepState=A.SLEEPY,this.timeLastSleepy=t,this.dispatchEvent(A.sleepyEvent)):e===A.SLEEPY&&s>i?this.wakeUp():e===A.SLEEPY&&t-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(A.sleepEvent))}}updateSolveMassProperties(){this.sleepState===A.SLEEPING||this.type===A.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(t,e){return void 0===e&&(e=new i),t.vsub(this.position,e),this.quaternion.conjugate().vmult(e,e),e}vectorToLocalFrame(t,e){return void 0===e&&(e=new i),this.quaternion.conjugate().vmult(t,e),e}pointToWorldFrame(t,e){return void 0===e&&(e=new i),this.quaternion.vmult(t,e),e.vadd(this.position,e),e}vectorToWorldFrame(t,e){return void 0===e&&(e=new i),this.quaternion.vmult(t,e),e}addShape(t,e,s){const n=new i,o=new u;return e&&n.copy(e),s&&o.copy(s),this.shapes.push(t),this.shapeOffsets.push(n),this.shapeOrientations.push(o),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=this,this}removeShape(t){const e=this.shapes.indexOf(t);return-1===e?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(e,1),this.shapeOffsets.splice(e,1),this.shapeOrientations.splice(e,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,t.body=null,this)}updateBoundingRadius(){const t=this.shapes,e=this.shapeOffsets,s=t.length;let i=0;for(let n=0;n!==s;n++){const s=t[n];s.updateBoundingSphereRadius();const o=e[n].length(),r=s.boundingSphereRadius;o+r>i&&(i=o+r)}this.boundingRadius=i}updateAABB(){const t=this.shapes,e=this.shapeOffsets,s=this.shapeOrientations,i=t.length,n=N,o=B,r=this.quaternion,a=this.aabb,h=M;for(let l=0;l!==i;l++){const i=t[l];r.vmult(e[l],n),n.vadd(this.position,n),r.mult(s[l],o),i.calculateWorldAABB(n,o,h.lowerBound,h.upperBound),0===l?a.copy(h):a.extend(h)}this.aabbNeedsUpdate=!1}updateInertiaWorld(t){const e=this.invInertia;if(e.x!==e.y||e.y!==e.z||t){const t=I,s=F;t.setRotationFromQuaternion(this.quaternion),t.transpose(s),t.scale(e,t),t.mmult(s,this.invInertiaWorld)}}applyForce(t,e){if(void 0===e&&(e=new i),this.type!==A.DYNAMIC)return;this.sleepState===A.SLEEPING&&this.wakeUp();const s=L;e.cross(t,s),this.force.vadd(t,this.force),this.torque.vadd(s,this.torque)}applyLocalForce(t,e){if(void 0===e&&(e=new i),this.type!==A.DYNAMIC)return;const s=T,n=q;this.vectorToWorldFrame(t,s),this.vectorToWorldFrame(e,n),this.applyForce(s,n)}applyTorque(t){this.type===A.DYNAMIC&&(this.sleepState===A.SLEEPING&&this.wakeUp(),this.torque.vadd(t,this.torque))}applyImpulse(t,e){if(void 0===e&&(e=new i),this.type!==A.DYNAMIC)return;this.sleepState===A.SLEEPING&&this.wakeUp();const s=e,n=R;n.copy(t),n.scale(this.invMass,n),this.velocity.vadd(n,this.velocity);const o=P;s.cross(t,o),this.invInertiaWorld.vmult(o,o),this.angularVelocity.vadd(o,this.angularVelocity)}applyLocalImpulse(t,e){if(void 0===e&&(e=new i),this.type!==A.DYNAMIC)return;const s=C,n=O;this.vectorToWorldFrame(t,s),this.vectorToWorldFrame(e,n),this.applyImpulse(s,n)}updateMassProperties(){const t=k;this.invMass=this.mass>0?1/this.mass:0;const e=this.inertia,s=this.fixedRotation;this.updateAABB(),t.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),E.calculateInertia(t,this.mass,e),this.invInertia.set(e.x>0&&!s?1/e.x:0,e.y>0&&!s?1/e.y:0,e.z>0&&!s?1/e.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(t,e){const s=new i;return t.vsub(this.position,s),this.angularVelocity.cross(s,e),this.velocity.vadd(e,e),e}integrate(t,e,s){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),this.type!==A.DYNAMIC&&this.type!==A.KINEMATIC||this.sleepState===A.SLEEPING)return;const i=this.velocity,n=this.angularVelocity,o=this.position,r=this.force,a=this.torque,h=this.quaternion,l=this.invMass,c=this.invInertiaWorld,u=this.linearFactor,d=l*t;i.x+=r.x*d*u.x,i.y+=r.y*d*u.y,i.z+=r.z*d*u.z;const p=c.elements,w=this.angularFactor,y=a.x*w.x,m=a.y*w.y,v=a.z*w.z;n.x+=t*(p[0]*y+p[1]*m+p[2]*v),n.y+=t*(p[3]*y+p[4]*m+p[5]*v),n.z+=t*(p[6]*y+p[7]*m+p[8]*v),o.x+=i.x*t,o.y+=i.y*t,o.z+=i.z*t,h.integrate(this.angularVelocity,t,this.angularFactor,h),e&&(s?h.normalizeFast():h.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}A.idCounter=0,A.COLLIDE_EVENT_NAME="collide",A.DYNAMIC=1,A.STATIC=2,A.KINEMATIC=4,A.AWAKE=0,A.SLEEPY=1,A.SLEEPING=2,A.wakeupEvent={type:"wakeup"},A.sleepyEvent={type:"sleepy"},A.sleepEvent={type:"sleep"};const N=new i,B=new u,M=new a,I=new e,F=new e,L=(new e,new i),T=new i,q=new i,R=new i,P=new i,C=new i,O=new i,k=new i;new i,new i,new u,new i,new i,new i,new i;class W{constructor(){this.rayFromWorld=new i,this.rayToWorld=new i,this.hitNormalWorld=new i,this.hitPointWorld=new i,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(t,e,s,i,n,o,r){this.rayFromWorld.copy(t),this.rayToWorld.copy(e),this.hitNormalWorld.copy(s),this.hitPointWorld.copy(i),this.shape=n,this.body=o,this.distance=r}}let V,D,H,Y,_,X,G;V=w.types.SPHERE,D=w.types.PLANE,H=w.types.BOX,Y=w.types.CYLINDER,_=w.types.CONVEXPOLYHEDRON,X=w.types.HEIGHTFIELD,G=w.types.TRIMESH;class U{get[V](){return this._intersectSphere}get[D](){return this._intersectPlane}get[H](){return this._intersectBox}get[Y](){return this._intersectConvex}get[_](){return this._intersectConvex}get[X](){return this._intersectHeightfield}get[G](){return this._intersectTrimesh}constructor(t,e){void 0===t&&(t=new i),void 0===e&&(e=new i),this.from=t.clone(),this.to=e.clone(),this.direction=new i,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=U.ANY,this.result=new W,this.hasHit=!1,this.callback=t=>{}}intersectWorld(t,e){return this.mode=e.mode||U.ANY,this.result=e.result||new W,this.skipBackfaces=!!e.skipBackfaces,this.collisionFilterMask=void 0!==e.collisionFilterMask?e.collisionFilterMask:-1,this.collisionFilterGroup=void 0!==e.collisionFilterGroup?e.collisionFilterGroup:-1,this.checkCollisionResponse=void 0===e.checkCollisionResponse||e.checkCollisionResponse,e.from&&this.from.copy(e.from),e.to&&this.to.copy(e.to),this.callback=e.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(j),$.length=0,t.broadphase.aabbQuery(t,j,$),this.intersectBodies($),this.hasHit}intersectBody(t,e){e&&(this.result=e,this.updateDirection());const s=this.checkCollisionResponse;if(s&&!t.collisionResponse)return;if(0==(this.collisionFilterGroup&t.collisionFilterMask)||0==(t.collisionFilterGroup&this.collisionFilterMask))return;const i=K,n=J;for(let e=0,o=t.shapes.length;e<o;e++){const o=t.shapes[e];if((!s||o.collisionResponse)&&(t.quaternion.mult(t.shapeOrientations[e],n),t.quaternion.vmult(t.shapeOffsets[e],i),i.vadd(t.position,i),this.intersectShape(o,n,i,t),this.result.shouldStop))break}}intersectBodies(t,e){e&&(this.result=e,this.updateDirection());for(let e=0,s=t.length;!this.result.shouldStop&&e<s;e++)this.intersectBody(t[e])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(t,e,s,i){const n=function(t,e,s){s.vsub(t,gt);const i=gt.dot(e);e.scale(i,zt),zt.vadd(t,zt);return s.distanceTo(zt)}(this.from,this.direction,s);if(n>t.boundingSphereRadius)return;const o=this[t.type];o&&o.call(this,t,e,s,i,t)}_intersectBox(t,e,s,i,n){return this._intersectConvex(t.convexPolyhedronRepresentation,e,s,i,n)}_intersectPlane(t,e,s,n,o){const r=this.from,a=this.to,h=this.direction,l=new i(0,0,1);e.vmult(l,l);const c=new i;r.vsub(s,c);const u=c.dot(l);if(a.vsub(s,c),u*c.dot(l)>0)return;if(r.distanceTo(a)<u)return;const d=l.dot(h);if(Math.abs(d)<this.precision)return;const p=new i,w=new i,y=new i;r.vsub(s,p);const m=-l.dot(p)/d;h.scale(m,w),r.vadd(w,y),this.reportIntersection(l,y,o,n,-1)}getAABB(t){const{lowerBound:e,upperBound:s}=t,i=this.to,n=this.from;e.x=Math.min(i.x,n.x),e.y=Math.min(i.y,n.y),e.z=Math.min(i.z,n.z),s.x=Math.max(i.x,n.x),s.y=Math.max(i.y,n.y),s.z=Math.max(i.z,n.z)}_intersectHeightfield(t,e,s,i,n){t.data,t.elementSize;const o=rt;o.from.copy(this.from),o.to.copy(this.to),y.pointToLocalFrame(s,e,o.from,o.from),y.pointToLocalFrame(s,e,o.to,o.to),o.updateDirection();const r=at;let h,l,c,u;h=l=0,c=u=t.data.length-1;const d=new a;o.getAABB(d),t.getIndexOfPosition(d.lowerBound.x,d.lowerBound.y,r,!0),h=Math.max(h,r[0]),l=Math.max(l,r[1]),t.getIndexOfPosition(d.upperBound.x,d.upperBound.y,r,!0),c=Math.min(c,r[0]+1),u=Math.min(u,r[1]+1);for(let r=h;r<c;r++)for(let a=l;a<u;a++){if(this.result.shouldStop)return;if(t.getAabbAtIndex(r,a,d),d.overlapsRay(o)){if(t.getConvexTrianglePillar(r,a,!1),y.pointToWorldFrame(s,e,t.pillarOffset,ot),this._intersectConvex(t.pillarConvex,e,ot,i,n,nt),this.result.shouldStop)return;t.getConvexTrianglePillar(r,a,!0),y.pointToWorldFrame(s,e,t.pillarOffset,ot),this._intersectConvex(t.pillarConvex,e,ot,i,n,nt)}}}_intersectSphere(t,e,s,i,n){const o=this.from,r=this.to,a=t.radius,h=(r.x-o.x)**2+(r.y-o.y)**2+(r.z-o.z)**2,l=2*((r.x-o.x)*(o.x-s.x)+(r.y-o.y)*(o.y-s.y)+(r.z-o.z)*(o.z-s.z)),c=l**2-4*h*((o.x-s.x)**2+(o.y-s.y)**2+(o.z-s.z)**2-a**2),u=ht,d=lt;if(!(c<0))if(0===c)o.lerp(r,c,u),u.vsub(s,d),d.normalize(),this.reportIntersection(d,u,n,i,-1);else{const t=(-l-Math.sqrt(c))/(2*h),e=(-l+Math.sqrt(c))/(2*h);if(t>=0&&t<=1&&(o.lerp(r,t,u),u.vsub(s,d),d.normalize(),this.reportIntersection(d,u,n,i,-1)),this.result.shouldStop)return;e>=0&&e<=1&&(o.lerp(r,e,u),u.vsub(s,d),d.normalize(),this.reportIntersection(d,u,n,i,-1))}}_intersectConvex(t,e,s,i,n,o){const r=ct,a=ut,h=o&&o.faceList||null,l=t.faces,c=t.vertices,u=t.faceNormals,d=this.direction,p=this.from,w=this.to,y=p.distanceTo(w),m=h?h.length:l.length,v=this.result;for(let t=0;!v.shouldStop&&t<m;t++){const o=h?h[t]:t,w=l[o],m=u[o],f=e,x=s;a.copy(c[w[0]]),f.vmult(a,a),a.vadd(x,a),a.vsub(p,a),f.vmult(m,r);const g=d.dot(r);if(Math.abs(g)<this.precision)continue;const z=r.dot(a)/g;if(!(z<0)){d.scale(z,tt),tt.vadd(p,tt),et.copy(c[w[0]]),f.vmult(et,et),x.vadd(et,et);for(let t=1;!v.shouldStop&&t<w.length-1;t++){st.copy(c[w[t]]),it.copy(c[w[t+1]]),f.vmult(st,st),f.vmult(it,it),x.vadd(st,st),x.vadd(it,it);const e=tt.distanceTo(p);!U.pointInTriangle(tt,et,st,it)&&!U.pointInTriangle(tt,st,et,it)||e>y||this.reportIntersection(r,tt,n,i,o)}}}}_intersectTrimesh(t,e,s,i,n,o){const r=dt,a=ft,h=xt,l=ut,c=pt,u=wt,d=yt,p=vt,w=mt,m=t.indices;t.vertices;const v=this.from,f=this.to,x=this.direction;h.position.copy(s),h.quaternion.copy(e),y.vectorToLocalFrame(s,e,x,c),y.pointToLocalFrame(s,e,v,u),y.pointToLocalFrame(s,e,f,d),d.x*=t.scale.x,d.y*=t.scale.y,d.z*=t.scale.z,u.x*=t.scale.x,u.y*=t.scale.y,u.z*=t.scale.z,d.vsub(u,c),c.normalize();const g=u.distanceSquared(d);t.tree.rayQuery(this,h,a);for(let o=0,h=a.length;!this.result.shouldStop&&o!==h;o++){const h=a[o];t.getNormal(h,r),t.getVertex(m[3*h],et),et.vsub(u,l);const d=c.dot(r),v=r.dot(l)/d;if(v<0)continue;c.scale(v,tt),tt.vadd(u,tt),t.getVertex(m[3*h+1],st),t.getVertex(m[3*h+2],it);const f=tt.distanceSquared(u);!U.pointInTriangle(tt,st,et,it)&&!U.pointInTriangle(tt,et,st,it)||f>g||(y.vectorToWorldFrame(e,r,w),y.pointToWorldFrame(s,e,tt,p),this.reportIntersection(w,p,n,i,h))}a.length=0}reportIntersection(t,e,s,i,n){const o=this.from,r=this.to,a=o.distanceTo(e),h=this.result;if(!(this.skipBackfaces&&t.dot(this.direction)>0))switch(h.hitFaceIndex=void 0!==n?n:-1,this.mode){case U.ALL:this.hasHit=!0,h.set(o,r,t,e,s,i,a),h.hasHit=!0,this.callback(h);break;case U.CLOSEST:(a<h.distance||!h.hasHit)&&(this.hasHit=!0,h.hasHit=!0,h.set(o,r,t,e,s,i,a));break;case U.ANY:this.hasHit=!0,h.hasHit=!0,h.set(o,r,t,e,s,i,a),h.shouldStop=!0}}static pointInTriangle(t,e,s,i){i.vsub(e,gt),s.vsub(e,Z),t.vsub(e,Q);const n=gt.dot(gt),o=gt.dot(Z),r=gt.dot(Q),a=Z.dot(Z),h=Z.dot(Q);let l,c;return(l=a*r-o*h)>=0&&(c=n*h-o*r)>=0&&l+c<n*a-o*o}}U.CLOSEST=1,U.ANY=2,U.ALL=4;const j=new a,$=[],Z=new i,Q=new i,K=new i,J=new u,tt=new i,et=new i,st=new i,it=new i;new i,new W;const nt={faceList:[0]},ot=new i,rt=new U,at=[],ht=new i,lt=new i,ct=new i,ut=(new i,new i,new i),dt=new i,pt=new i,wt=new i,yt=new i,mt=new i,vt=new i;new a;const ft=[],xt=new y,gt=new i,zt=new i;class Et{static defaults(t,e){void 0===t&&(t={});for(let s in e)s in t||(t[s]=e[s]);return t}}class bt{constructor(t,e,s){void 0===s&&(s={}),s=Et.defaults(s,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=t,this.bodyB=e,this.id=bt.idCounter++,this.collideConnected=s.collideConnected,s.wakeUpBodies&&(t&&t.wakeUp(),e&&e.wakeUp())}update(){throw new Error("method update() not implmemented in this Constraint subclass!")}enable(){const t=this.equations;for(let e=0;e<t.length;e++)t[e].enabled=!0}disable(){const t=this.equations;for(let e=0;e<t.length;e++)t[e].enabled=!1}}bt.idCounter=0;class St{constructor(){this.spatial=new i,this.rotational=new i}multiplyElement(t){return t.spatial.dot(this.spatial)+t.rotational.dot(this.rotational)}multiplyVectors(t,e){return t.dot(this.spatial)+e.dot(this.rotational)}}class At{constructor(t,e,s,i){void 0===s&&(s=-1e6),void 0===i&&(i=1e6),this.id=At.idCounter++,this.minForce=s,this.maxForce=i,this.bi=t,this.bj=e,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new St,this.jacobianElementB=new St,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(t,e,s){const i=e,n=t,o=s;this.a=4/(o*(1+4*i)),this.b=4*i/(1+4*i),this.eps=4/(o*o*n*(1+4*i))}computeB(t,e,s){const i=this.computeGW();return-this.computeGq()*t-i*e-this.computeGiMf()*s}computeGq(){const t=this.jacobianElementA,e=this.jacobianElementB,s=this.bi,i=this.bj,n=s.position,o=i.position;return t.spatial.dot(n)+e.spatial.dot(o)}computeGW(){const t=this.jacobianElementA,e=this.jacobianElementB,s=this.bi,i=this.bj,n=s.velocity,o=i.velocity,r=s.angularVelocity,a=i.angularVelocity;return t.multiplyVectors(n,r)+e.multiplyVectors(o,a)}computeGWlambda(){const t=this.jacobianElementA,e=this.jacobianElementB,s=this.bi,i=this.bj,n=s.vlambda,o=i.vlambda,r=s.wlambda,a=i.wlambda;return t.multiplyVectors(n,r)+e.multiplyVectors(o,a)}computeGiMf(){const t=this.jacobianElementA,e=this.jacobianElementB,s=this.bi,i=this.bj,n=s.force,o=s.torque,r=i.force,a=i.torque,h=s.invMassSolve,l=i.invMassSolve;return n.scale(h,Nt),r.scale(l,Bt),s.invInertiaWorldSolve.vmult(o,Mt),i.invInertiaWorldSolve.vmult(a,It),t.multiplyVectors(Nt,Mt)+e.multiplyVectors(Bt,It)}computeGiMGt(){const t=this.jacobianElementA,e=this.jacobianElementB,s=this.bi,i=this.bj,n=s.invMassSolve,o=i.invMassSolve,r=s.invInertiaWorldSolve,a=i.invInertiaWorldSolve;let h=n+o;return r.vmult(t.rotational,Ft),h+=Ft.dot(t.rotational),a.vmult(e.rotational,Ft),h+=Ft.dot(e.rotational),h}addToWlambda(t){const e=this.jacobianElementA,s=this.jacobianElementB,i=this.bi,n=this.bj,o=Lt;i.vlambda.addScaledVector(i.invMassSolve*t,e.spatial,i.vlambda),n.vlambda.addScaledVector(n.invMassSolve*t,s.spatial,n.vlambda),i.invInertiaWorldSolve.vmult(e.rotational,o),i.wlambda.addScaledVector(t,o,i.wlambda),n.invInertiaWorldSolve.vmult(s.rotational,o),n.wlambda.addScaledVector(t,o,n.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}At.idCounter=0;const Nt=new i,Bt=new i,Mt=new i,It=new i,Ft=new i,Lt=new i;new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i;class Tt{constructor(t,e,s){s=Et.defaults(s,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=Tt.idCounter++,this.materials=[t,e],this.friction=s.friction,this.restitution=s.restitution,this.contactEquationStiffness=s.contactEquationStiffness,this.contactEquationRelaxation=s.contactEquationRelaxation,this.frictionEquationStiffness=s.frictionEquationStiffness,this.frictionEquationRelaxation=s.frictionEquationRelaxation}}Tt.idCounter=0;class qt{constructor(t){void 0===t&&(t={});let e="";"string"==typeof t&&(e=t,t={}),this.name=e,this.id=qt.idCounter++,this.friction=void 0!==t.friction?t.friction:-1,this.restitution=void 0!==t.restitution?t.restitution:-1}}qt.idCounter=0,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new U,new i,new i,new i,new i(1,0,0),new i(0,1,0),new i(0,0,1),new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new a,new i,new a,new i,new i,new i,new i,new i,new i,new i,new a,new i,new y,new a,A.STATIC,w.types.SPHERE,w.types.SPHERE,w.types.PLANE,w.types.BOX,w.types.BOX,w.types.SPHERE,w.types.BOX,w.types.PLANE,w.types.BOX,w.types.CONVEXPOLYHEDRON,w.types.SPHERE,w.types.CONVEXPOLYHEDRON,w.types.PLANE,w.types.CONVEXPOLYHEDRON,w.types.BOX,w.types.CONVEXPOLYHEDRON,w.types.SPHERE,w.types.HEIGHTFIELD,w.types.BOX,w.types.HEIGHTFIELD,w.types.CONVEXPOLYHEDRON,w.types.HEIGHTFIELD,w.types.PARTICLE,w.types.SPHERE,w.types.PLANE,w.types.PARTICLE,w.types.BOX,w.types.PARTICLE,w.types.PARTICLE,w.types.CONVEXPOLYHEDRON,w.types.CYLINDER,w.types.SPHERE,w.types.CYLINDER,w.types.PLANE,w.types.CYLINDER,w.types.BOX,w.types.CYLINDER,w.types.CONVEXPOLYHEDRON,w.types.CYLINDER,w.types.HEIGHTFIELD,w.types.CYLINDER,w.types.PARTICLE,w.types.CYLINDER,w.types.SPHERE,w.types.TRIMESH,w.types.PLANE,w.types.TRIMESH,new i,new i,new i,new i,new i,new u,new u,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new a,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new i,new u,new i,new i,new i,new i,new i,new i,new i,new i,new i,new a,new U;const Rt=globalThis.performance||{};if(!Rt.now){let t=Date.now();Rt.timing&&Rt.timing.navigationStart&&(t=Rt.timing.navigationStart),Rt.now=()=>Date.now()-t}function Pt(){return new Worker(t.p+"worker.worker.js")}new i,A.COLLIDE_EVENT_NAME;const Ct=new Array;let Ot,kt=0,Wt=0;for(let t=0;t<3;t++)Ot=new Pt("worker.js",{type:"module"}),Ot.onmessage=Dt,Ot.onerror=Ht,Ot.id=t,Ot.collectors=new Object,Ct[t]=Ot;class Vt{collID;numExpected;numAcquired=0;dmin=Number.MAX_VALUE;vector;finished=!1;ready;resolveReady;constructor(t,e){this.collID=t,this.vector=new i,this.numExpected=e,this.ready=new Promise(((t,e)=>{this.resolveReady=t})),Ct.forEach((t=>{t.collectors[this.collID]=this}))}sendTask(t,e,s,i,n){Ot=Ct[Wt],Wt=(Wt+1)%3,Ot.postMessage([this.collID,e,s,i,n,t])}}function Dt(t){console.log(t.data);const e=t.data[0],s=t.data[1],i=this.collectors[e];0==s?(i.dmin=!1,i.finished=!0,i.resolveReady()):s<i.dmin&&(i.dmin=s,i.vector=t.data[2]),i.numAcquired+=1,i.numAcquired==i.numExpected&&(i.finished=!0,i.resolveReady())}function Ht(t){throw console.log("error occurred in worker "+t.srcElement.id+":\n"+t.message+"\n"+t.filename+"\n"+t.lineno),t}const Yt=new E(new i(1,1,1)).convexPolyhedronRepresentation,_t=new i(-5,0,0),Xt=new u(0,0,0,1),Gt=(new A({mass:1,position:_t,shape:Yt}),new E(new i(1,1,1)).convexPolyhedronRepresentation),Ut=new i(0,0,0),jt=new u(0,0,0,1);new A({mass:1,position:Ut,shape:Gt}),console.log("start test"),async function(t,e,s,n,o,r,a,h,l){const c=new i,u=new i,d=new i,p=new i,w=new i,y=new i;let m=t.uniqueEdges.length*e.uniqueEdges.length;t.uniqueAxes?m+=t.uniqueAxes.length:m+=numFacesA,e.uniqueAxes?m+=e.uniqueAxes.length:m+=numFacesB;const v=new Vt(kt,m);if(kt+=1,t.uniqueAxes)for(let e=0;e!==t.uniqueAxes.length;e++)n.vmult(t.uniqueAxes[e],c),v.sendTask(c,s,n,o,r);else{const e=h?h.length:t.faces.length;for(let i=0;i<e;i++){const e=h?h[i]:i;c.copy(t.faceNormals[e]),n.vmult(c,c),v.sendTask(c,s,n,o,r)}}if(e.uniqueAxes)for(let t=0;t!==e.uniqueAxes.length;t++)r.vmult(e.uniqueAxes[t],u),v.sendTask(u,s,n,o,r);else{const t=l?l.length:e.faces.length;for(let i=0;i<t;i++){const t=l?l[i]:i;u.copy(e.faceNormals[t]),r.vmult(u,u),v.sendTask(u,s,n,o,r)}}for(let i=0;i!==t.uniqueEdges.length;i++){n.vmult(t.uniqueEdges[i],p);for(let t=0;t!==e.uniqueEdges.length;t++)r.vmult(e.uniqueEdges[t],w),p.cross(w,y),y.almostZero()||(y.normalize(),v.sendTask(y,s,n,o,r))}console.log("waiting for collector"),await v.ready,console.log("collector is ready"),a=v.vector,o.vsub(s,d),d.dot(a)>0&&a.negate(a)}(Yt,Gt,_t,Xt,Ut,jt),console.log("end test")})();